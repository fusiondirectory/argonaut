#!/usr/bin/perl -w

#######################################################################
#
# argonaut-fuse -- fuse-supplicant which allows one to create pxelinux 
#                  configurations for different types of clients using
#                  external modules.
#
# Copyright (c) 2005,2006,2007 by Jan-Marek Glogowski <glogow@fbihome.de>
# Copyright (c) 2008 by Cajus Pollmeier <pollmeier@gonicus.de>
# Copyright (c) 2008,2009, 2010 by Jan Wenzel <wenzel@gonicus.de>
# Copyright (C) 2011 FusionDirectory project <contact@fusiondirectory.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#######################################################################

use strict;
use warnings;

use 5.008;

use POSIX;
use FindBin;
use Socket;
use Fuse;

use Data::Dumper;
use File::Pid;
use Getopt::Long;
use Config::IniFiles;
use Storable qw(freeze thaw);
use Time::HiRes qw(gettimeofday usleep);
use Net::LDAP;
use Log::Handler;

use Argonaut::Common qw(:ldap :file);

use constant USEC => 1000000;

use lib "/usr/lib/argonaut/modules";

our $ldap_base;
our @ldapuris;
our $parse_uris;
our $ldap_handle;

our $config = '/etc/argonaut-fuse/argonaut-fuse.conf';
our $filesystem;
our $last_attred_file;

# Parse options and allow '-vvv'
Getopt::Long::Configure( 'bundling' );
GetOptions( 'h|help' => \&usage,
            'c|config=s' => \$config)
  or usage( '', 1 );

#where to look for modules files
my $modules_path= "/usr/lib/argonaut/modules";

# logfile name and dir
my $logfile = "argonaut-fuse.log";
my $logdir;

# Predefined variables for config
my $pidfile;
our( $ldap_conf, $ldap_dn, $ldap_pwd );
our( $tftp_root, $tftp_static_root );
our( $known_modules);
our( $default_mode );

# All default values
our %cfg_defaults = (
  'basic' => {
    'pidfile'      => [ \$pidfile,   '/var/run/argonaut-fuse.pid' ],
    'logdir'       => [ \$logdir,   '/var/log/argonaut/' ],
    'default_mode' => [ \$default_mode, 'install' ], # 'install', 'fallback';;
  },
  'ldap' => {
    'config'    => [ \$ldap_conf, '/etc/ldap/ldap.conf' ],
    'dn'        => [ \$ldap_dn,   undef ],
    'password'  => [ \$ldap_pwd,  undef ],
  },
  'tftp' => {
    'pxelinux_cfg'          => [ \$tftp_root, '/tftpboot/pxelinux.cfg' ],
    'pxelinux_cfg_static'   => [ \$tftp_static_root, '/tftpboot/pxelinux.static' ],
  }
);

# Read config file
my $cfg;
if( defined $config && (length($config) > 0) ) {
  if( -r $config )
    { $cfg = Config::IniFiles->new( -file => $config ); }
  else { die("Couldn't read config file: $config"); }
}
else { $cfg = Config::IniFiles->new(); }

# "Parse" config into values
foreach my $section (keys %cfg_defaults) {
  foreach my $param (keys %{$cfg_defaults{ $section }}) {
    my $pinfo = $cfg_defaults{ $section }{ $param };
    ${@$pinfo[ 0 ]} = $cfg->val( $section, $param, @$pinfo[ 1 ] );
  }
}

# Parse LDAP configuration
  ($ldap_base,$parse_uris) = argonaut_ldap_parse_config( $ldap_conf );
  die ( "Couldn't find LDAP base in config!" ) if( ! defined $ldap_base );
  die ( "Couldn't find LDAP URI in config!" ) if( ! defined $parse_uris );
  @ldapuris = ( @$parse_uris );

argonaut_create_dir($logdir);

my $log = Log::Handler->create_logger("argonaut-fuse");

$log->add(
    file => {
        filename => "$logdir/$logfile",
        maxlevel => "debug",
        minlevel => "emergency",
        newline  => 1,
    }
);

$log->info("Argonaut-Fuse Started\n");

# Scan for modules - these can set their own config sections.

import_modules();

my $mountpoint = $tftp_root;

# Create the PID object
# Ensure you put a name that won't clobber
#   another program's PID file
my $pid = File::Pid->new({
   file  => $pidfile,
});

# Write the PID file
$pid->write;

$filesystem= {
  root => {
    content => {}
  }
};

$log->info("Argonaut-Fuse Mounting $tftp_static_root\n");

# Open static directory
my $tftp_static_root_handle;
opendir($tftp_static_root_handle, $tftp_static_root);

# Mount FUSE Filesystem
Fuse::main(
  mountpoint=>$mountpoint,
  mountopts => "nonempty,allow_other",
  getattr => \&getattr,
  read => \&read,
  getdir => \&getdir,
  debug => 0,
  threaded => 0,
);

exit 0;

sub INT_handler {

  $pidfile->remove or warn "Could not remove $pidfile\n";
  
  exit(0);

}

##############################
#
# @brief Prepare the childs' LDAP handle.
#
# @return int 0 on error, 1 on success
#
sub prepare_ldap_handle {
  my $mesg;

  # Get an ldap handle, if we don't have one
  $ldap_handle = Net::LDAP->new( \@main::ldapuris )
    if( ! defined $ldap_handle );
  if( ! defined $ldap_handle ) {
    $log->error("ch $$: Net::LDAP constructor failed: $!\n");
    return 0;
  }

  # Bind to ldap server - eventually authenticate
  if( defined $ldap_dn ) {
    if( defined $ldap_pwd )
      { $mesg = $ldap_handle->bind( $ldap_dn, password => $ldap_pwd ); }
    else { $mesg = $ldap_handle->bind( $ldap_dn ); }
  }
  else {
    $mesg = $ldap_handle->bind();
  }

  if( 0 != $mesg->code ) {
    undef( $ldap_handle ) if( 81 == $mesg->code );
    $log->error("ch $$: LDAP bind: error $mesg->code - $mesg->error.\n");
    return 0;
  }

  return 1;
}

##############################
#
# @brief Try multiple to get a valid connection
#
# All values in microseconds (1.000.000)
#
# @param $timeout  - timeout for reconnections
# @param $retry    - retries to establish a connection superseded by timeout
# @param $sleep    - minimum sleep time
# @param $multiply - multiply time after each sleep
# @param $add      - add to time after sleep
# @param $max      - maximum sleep time
#
# @return $bool true, if LDAP bind was successful.
#
sub prepare_ldap_handle_retry {

  my( $timeout, $retry, $sleep, $multiply, $add, $max ) = @_;
  my $valid_handle;

  # Some default fallbacks
  $timeout = 0 if( ! defined $timeout );
  $retry = -1 if( ! defined $retry );
  $sleep = USEC if( ! defined $sleep );
  $multiply = 1.0 if( ! defined $multiply );
  $add = 0 if( ! defined $add );
  $max = -1 if( ! defined $max );

  # Max time if we have a timeout
  my( $epo_secs, $epo_msecs );
  if( $timeout >= 0 ) {
     ( $epo_secs, $epo_msecs ) = gettimeofday();
     $timeout += $epo_secs * USEC + $epo_msecs;
  }

  # Reminder!!!
  # last doesn't work with do {} while ()
  while( 1 ) {
    $valid_handle = prepare_ldap_handle();
    last if( $valid_handle );
    $retry-- if( 0 < $retry );

    if( $timeout >= 0 ) {
      ( $epo_secs, $epo_msecs ) = gettimeofday();
      my $max_sleep = $timeout - $epo_secs * USEC - $epo_msecs;
      if( $sleep > $max_sleep )
        { $sleep = $max_sleep; }
      last if( $sleep <= 0 );
    }

    my $secs = $sleep / USEC;
    $log->info( "ch $$: connection error - sleeping for $secs seconds.\n" );
    usleep( $sleep );

    if( (0 >= $max) || ($sleep < $max) ) {
      $sleep *= $multiply;
      $sleep += $add;
      if( (0 < $max) && ($sleep > $max) )
        { $sleep = $max; }
    }

    last if( $valid_handle || (0 == $retry) );
    my $sleep_sec = $sleep / 1000000;
    $log->info( "ch $$: next sleep: $sleep_sec seconds.\n" );
  }

  return $valid_handle;
}
 
sub write_pxe_config_file {

  my ($host,$file,$kernel,$append) = @_;

  # Get IP address
  my $ip_bytes = inet_aton( $host ) if($host);
  my $ipaddr = (defined $ip_bytes) ? inet_ntoa( $ip_bytes ) : 'unknown';
  if(not $host or "" eq $host) {
    $host = $ipaddr;
  }

  my $file_content= "#generated by argonaut-fuse for host $host with IP $ipaddr\n";
  $file_content.= "default argonaut-fuse-generated\n\n";
  $file_content.= "label argonaut-fuse-generated\n";
  $file_content.= "$kernel\n";
  if($append) {
    $file_content.= "append $append\n";
  }

  # store in hash
  $filesystem->{'root'}->{'content'}->{$file}->{'type'}= 'file';
  $filesystem->{'root'}->{'content'}->{$file}->{'content'}= $file_content;

  return 0;
}


#===  FUNCTION  ================================================================
#         NAME:  import_modules
#   PARAMETERS:  module_path - string - abs. path to the directory the modules 
#                are stored
#      RETURNS:  nothing
#  DESCRIPTION:  each file in module_path which ends with '.pm' and activation 
#                state is on is imported by "require 'file';"
#===============================================================================
sub import_modules {
  if (not -e $modules_path) {
    $log->error("Cannot find directory or directory is not readable: $modules_path\n");
  }

  opendir (DIR, $modules_path) or die "ERROR while loading modules from directory $modules_path : $!\n";
  while (defined (my $file = readdir (DIR))) {
    if (not $file =~ /(\S*?).pm$/) {
      next;
    }
    my $mod_name = $1;

    eval { require $file; };
    if ($@) {
      $log->error("argonaut-fuse could not load module $file");
      $log->error("$@");
    } else {
      my $info = eval($mod_name.'::get_module_info()');
      # Only load module if get_module_info() returns a non-null object
      if( $info ) {
        $known_modules->{$mod_name} = $info;
        
        # Load additional configuration values
        $log->info("Adding additional config sections for Module $mod_name\n");
        $cfg_defaults{$mod_name}= eval($mod_name.'::get_config_sections')
          if(eval($mod_name.'::get_config_sections'));
      }
    }
  }

  close (DIR);
}

sub getattr {
  my ($filename) = @_;

  # regular file
  my $type = 0100;
  my $bits = 0644;

  my $current = $filesystem->{'root'}->{'content'};
  my @path_elements = split( '/', $filename );
  my $current_type = 'file';

  if ( @path_elements > 1 ) {
    foreach my $path_element ( @path_elements[1..$#path_elements] ) {
      if ($path_element =~ /^[0-9a-f]{1,2}-[0-9a-f]{1,2}-[0-9a-f]{1,2}-[0-9a-f]{1,2}-[0-9a-f]{1,2}-[0-9a-f]{1,2}-[0-9a-f]{1,2}$/i) {
        # Always generate a fresh config
        delete $current->{$path_element} if(exists($current->{$path_element}));

        # Process known Modules
        MODULE: foreach my $module (keys %{$known_modules}) {
          $log->info("Processing Module $module with argument ${path_element}\n");
          no strict "refs";
          my $answer = &{ $module."::get_pxe_config" }($path_element);
          if(exists($current->{$path_element})) {
            last MODULE;
          }
          if($@) {
            $log->error("ERROR: Processing Module $module failed with $@\n");
          }
        }
      }
      if (not defined( $current->{$path_element} ) ) {
        if(-r $tftp_static_root.'/'.$path_element) { 
          return stat($tftp_static_root.'/'.$path_element);
        } else {
          return -1*ENOENT;
        }
      }
      $current_type = $current->{$path_element}->{'type'};
      $last_attred_file = $current->{$path_element} if ( $current_type eq 'file' );
      $current = $current->{$path_element}->{'content'} if ( $current_type eq 'dir' );
    }
  }

  # if directory, set type to dir and mode to 0755
  if ( $filename eq '/' || $current_type eq 'dir' ) {
    $type = 0040;
    $bits = 0755;
  }

  my $mode = $type << 9 | $bits;
  my $nlink = 1;
  my $uid = $<;
  my ($gid) = split / /, $(;
  my $rdev = 0;
  my $atime = time;
  my $size = 0;

  if ( $current_type eq 'file' ) {
    $size = length( $last_attred_file->{'content'} ) if($last_attred_file->{'content'});
  }

  my $mtime = $atime;
  my $ctime = $atime;

  my $blksize = 1024;
  my $blocks = 1;
  
  my $dev = 0;
  my $ino = 0;

  return ( $dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size, $atime, $mtime, $ctime, $blksize, $blocks );
}

sub read {
  my ($pathname, $requestedsize, $offset) = @_;
  my $current= $filesystem->{'root'}->{'content'};
  my @path_elements= split('/', $pathname);

  if(@path_elements > 1) {
    foreach my $path_element (@path_elements[1..$#path_elements]) {
      if(not defined($current->{$path_element})) {
        if(-r $tftp_static_root.$pathname) {
          # TODO: dies when file exceeds buffersize
          my ($content, $buffer);
          sysopen(FH, $tftp_static_root.$pathname, O_RDONLY) or return ( -1*ENOENT );
          binmode(FH);
          sysread(FH, $content, $requestedsize, $offset);
          close(FH);
          return $content;
        } else {
          return( -1*ENOENT );
        }
      }
      $current = $current->{$path_element}->{'content'};
    }
  }

  return $current;
}

sub getdir {
  my ($filename) = @_;
  my $current = $filesystem->{'root'}->{'content'};
  my @path_elements= split('/', $filename);
  my @result= ('.', '..');

  if(@path_elements > 1) {
    foreach my $path_element (@path_elements[1..$#path_elements]) {
      return(-1*ENOENT) if(not defined($current->{$path_element}));
      $current= $current->{$path_element}->{'content'};
    }
  }

  push @result, keys(%{$current});

  if(defined($tftp_static_root_handle)) {
    foreach my $path_element(readdir($tftp_static_root_handle)) {
      next if($path_element eq '.');
      next if($path_element eq '..');
      push @result, $path_element;
    }
    rewinddir($tftp_static_root_handle);
  }

  push @result, 0;
  return @result;
}

#############################
#
# @brief Display error message and/or help text.
#
# In correspondence to previous GetOptions
#
# @param $text - string to print as error message
# @param $help - set true, if you want to show usage help
#
sub usage
{
    print STDERR << "EOF";

  usage: $0 [-h] [-c config]

   -h        : this (help) message
   -c <cfg>  : config file (default: ${config})
   
EOF

  exit( -1 );
}



1;

__END__


=head1 NAME

argonaut-fuse - FUSE/TFTP supplicant targeted to work with LDAP entries written by FusionDirectory

=head1 SYNOPSIS

argonaut-fuse [-h] [-c config] 

=head1 DESCRIPTION

B<argonaut-fuse> is a modular fuse-tftp-supplicant written in perl which allows one to create pxelinux configurations for different types of clients using external modules.
There is already written modules for FAI (Fully automated install).

=over 10

=item B<-c> <cfg>  argonaut-fuse config file (default: /etc/argonaut-fuse/argonaut-fuse.conf)

=item B<-h>        display this help and exit

=back

=head1 BUGS

Please report any bugs, or post any suggestions, to the fusiondirectory mailing list fusiondirectory-users or to
<https://forge.fusiondirectory.org/projects/argonaut-agents/issues/new>

=head1 LICENCE AND COPYRIGHT

This code is part of FusionDirectory <http://www.fusiondirectory.org>

This code was Based on ctftpd

=over 5

=item Copyright (c) 2005,2006,2007 by Jan-Marek Glogowski <glogow@fbihome.de>

=item Copyright (c) 2008 by Cajus Pollmeier <pollmeier@gonicus.de>

=item Copyright (c) 2008,2009 by Jan Wenzel <wenzel@gonicus.de>

=item Copyright (C) 2010 by Jan Wenzel <wenzel@gonicus.de>

=item Copyright (C) 2011 FusionDirectory project

=back

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=cut

# vim:ts=2:sw=2:expandtab:shiftwidth=2:syntax:paste
