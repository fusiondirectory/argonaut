#!/usr/bin/perl

#######################################################################
#
# argonaut-server -- Json-rpc server for deployment
#
# Copyright (C) 2011 FusionDirectory project
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#######################################################################
#######################################################################
#  The wakeonlan part is taken from FusionInventory
#  Copyright (C) 2011  FusionInventory
#######################################################################

use strict;
use warnings;

use 5.008;

use POE qw(Component::Schedule Component::Server::JSONRPC::Http);
use DateTime;
use DateTime::Set;
use Data::Dumper;
use Net::LDAP;
use JSON::RPC::Client;
use JSON;
use Config::IniFiles;
use File::Path;
use Log::Handler;
use App::Daemon qw(daemonize);

use Argonaut::Common qw(:ldap :file);
use Argonaut::Packages qw(get_packages_info store_packages_file);

# where to look for modules files
use Module::Pluggable search_path => 'Argonaut::Server::Modules', sub_name => 'modules', require => 1;

use constant ETH_P_ALL => 0x0003;
use constant PF_PACKET => 17;
use constant SOCK_PACKET => 10;

use English qw(-no_match_vars);
use Socket;

our ($ldap_configfile,$ldap_dn,$ldap_password,$protocol,$server_ip,$server_port);
my ($sslkeyfile,$sslcertfile,$iptool,$delete_finished_tasks,
    $interface,$logdir,$packages_folder);
my $configfile = "/etc/argonaut/argonaut.conf";
my $logfile = "argonaut-server.log";
my $piddir = "/var/run/argonaut";
my $pidfile = "argonaut-server.pid";

readConfig();

argonaut_create_dir($logdir);

our $log = Log::Handler->create_logger("argonaut-server");

$log->add(
    file => {
        filename => "$logdir/$logfile",
        #~ maxlevel => "debug",
        maxlevel => "info",
        minlevel => "emergency",
        newline  => 1,
    }
);

$App::Daemon::pidfile = "$piddir/$pidfile";
$App::Daemon::logfile = "$logdir/$logfile";
$App::Daemon::as_user = "root";

argonaut_create_dir($piddir);

daemonize();


=pod
=item readConfig
Read config infos from the config file and erase them with LDAP infos
No parameters needed
=cut
sub readConfig {
  readConfigFile();
  readLdapConfig();
}

=pod
=item readConfigFile
Read from the config file argonaut.conf all the informations
No parameters needed
=cut
sub readConfigFile {
    my $config = Config::IniFiles->new( -file => $configfile, -allowempty => 1, -nocase => 1);

    $server_ip              =   $config->val( server => "server_ip"             ,"");
    $ldap_configfile        =   $config->val( ldap => "config"                  ,"/etc/ldap/ldap.conf");
    $ldap_dn                =   $config->val( ldap => "dn"                      ,"");
    $ldap_password          =   $config->val( ldap => "password"                ,"");
}

=pod
=item readLdapConfig
Read config infos from the LDAP
No parameters needed
=cut
sub readLdapConfig {
  my $settings = argonaut_get_server_settings($ldap_configfile,$ldap_dn,$ldap_password,$server_ip);

  $protocol               = $settings->{'protocol'};
  $server_port            = $settings->{'port'};
  $iptool                 = $settings->{'iptool'};
  $delete_finished_tasks  = $settings->{'delete_finished_tasks'};
  $interface              = $settings->{'interface'};
  $logdir                 = $settings->{'logdir'};
  $sslkeyfile             = $settings->{'keyfile'};
  $sslcertfile            = $settings->{'certfile'};

  $packages_folder        = "/var/cache/argonaut/packages";
}

=item bindLdap
Connect to ldap and return handle.
=cut
sub bindLdap {
    my $ldapinfos = argonaut_ldap_init ($ldap_configfile, 0, $ldap_dn, 0, $ldap_password);
    return ($ldapinfos->{'HANDLE'},$ldapinfos->{'BASE'});
}

=pod
=item getIpFromMac
Search in the ldap for the IP associated to a Mac address.
Parameter : the mac address
=cut
sub getIpFromMac {
  my ($mac) = @_;

  my ($ldap,$ldap_base) = bindLdap();

  my $mesg = $ldap->search( # perform a search
            base   => $ldap_base,
            filter => "macAddress=$mac",
                        attrs => [ 'ipHostNumber' ]
            );

  $mesg->code && die "Error while searching IP for mac address '$mac' :".$mesg->error;

  if(scalar($mesg->entries)>1) {
    $log->error("Multiple IPs were found for the Mac address '$mac'!");
    die "Multiple IPs were found for the Mac address '$mac'!";
  } elsif(scalar($mesg->entries)<1) {
    $log->error("No IPs were found for the Mac address '$mac'!");
    die "No IPs were found for the Mac address '$mac'!";
  }

  my $ip = ($mesg->entries)[0]->get_value("ipHostNumber");

  $mesg = $ldap->unbind;   # take down session

  return $ip;
}

=pod
=item wakeOnLan
Send a wake on lan package to a mac address
Parameter : the mac address
inspired by WakeOnLan.pm file from FusionInventory
=cut
sub wakeOnLan {
    my ($macaddress) = @_;

    $log->info("wake on lan");

    return unless defined $macaddress;

    $macaddress =~ s/://g;

    ###  for LINUX ONLY ###
    if ( eval { socket(SOCKET, PF_PACKET, SOCK_PACKET, getprotobyname('tcp')) or $log->info($!) and 0; }) {

        setsockopt(SOCKET, SOL_SOCKET, SO_BROADCAST, 1)
            or warn "Can't do setsockopt: $ERRNO\n";

        open my $handle, '-|', "$iptool -a $interface"
            or die "Can't run $iptool: $ERRNO";
        while (my $line = <$handle>) {
            next unless $line =~ /$interface \s+ Link \s \S+ \s+ HWaddr \s (\S+)/x;
            my $netMac = $1;
            $log->info("Send magic packet to $macaddress directly on card driver");
            $netMac =~ s/://g;

            my $magic_packet =
                (pack('H12', $macaddress)) .
                (pack('H12', $netMac)) .
                (pack('H4', "0842"));
            $magic_packet .= chr(0xFF) x 6 . (pack('H12', $macaddress) x 16);
            my $destination = pack("Sa14", 0, $interface);
            send(SOCKET, $magic_packet, 0, $destination)
                or warn "Couldn't send packet on $interface: $ERRNO\n";
        }
        close $handle;
        # TODO : For FreeBSD, send to /dev/bpf ....
    } else { # degraded wol by UDP
        if ( eval { socket(SOCKET, PF_INET, SOCK_DGRAM, getprotobyname('udp')); }) {
            my $magic_packet =
                chr(0xFF) x 6 .
                (pack('H12', $macaddress) x 16);
            my $sinbroadcast = sockaddr_in("9", inet_aton("255.255.255.255"));
            $log->info("Send magic packet to $macaddress in UDP mode (degraded wol)");
            send(SOCKET, $magic_packet, 0, $sinbroadcast);
        } else {
            $log->error("Impossible to send magic packet...");
        }
    }
}

sub convert_entry {
    my ($entry,$id) = @_;
    my $res = {};
    $res->{$_} = $entry->{$_} for ('action','data','target','status','substatus','progress','error');
    $res->{id} = $id;
    return $res;
}

sub ldap_authenticate {
  my ($login, $password) = @_;
  if (!defined($login) || !defined($password)) {
    return 0;
  }
  my $ldapinfos = argonaut_ldap_init ($ldap_configfile, 0, $login, 0, $password);

  if ( $ldapinfos->{'ERROR'} > 0) {
    return 0;
  }

  return 1;
}

=pod
=head2 POE Session
=over
=item _start
=item echo
=item ping
Ping the jsonrpc daemon of a client.
=item id_of_mac
Used by clients to get the taskid associated to them
=item set_task_substatus
Used by clients to set the fai status
=item set_error
Used by clients to signal fai errors
=item schedule
Internal state used for scheduling
=item add
Internal state corresponding at external action method call.
Launch the action or schedule it.
=item get_entries_by_id
Used by FD to get a bunch of entries by giving a bunch of ids
=item get_entries_by_mac
Used by FD to get a bunch of entries by giving a bunch of macs
=item remove_entries
Used by FD to remove entries by giving their ids
=item process_entries
Used by FD to ask the immediate launch of a bunch of actions by giving their ids
=item action
Internal state called by the scheduler to actually launch the action.
It calls do_action.
=item load_dump
Unused right now
=item sighup
When sighup received, reload config. See readConfig above.
(Also restart the server since its port might have changed)
=item sigint
When sigint received, write a json dump before quitting.
=item _stop
=back
=cut
POE::Session->create(
    inline_states => {
        _start => sub {
            $_[KERNEL]->sig( INT => "sigint", ("sigint"));
            $_[KERNEL]->sig( TERM => "sigint", ("sigterm"));
            $_[KERNEL]->sig( KILL => "sigint", ("sigkill"));
            $_[KERNEL]->sig( HUP => "sighup" );
            $_[HEAP]{tasks} = {};
            $_[HEAP]{id} = 0;

            $_[HEAP]{jsonserver} = POE::Component::Server::JSONRPC::Http->new(
                json    => JSON->new->utf8,
                Port    => $server_port,
                Handler => {
                    'echo' => 'echo',
                    'ping' => 'ping',
                    'action' => 'add',
                    'get_entries' => 'get_entries_by_id',
                    'get_entries_by_id' => 'get_entries_by_id',
                    'get_entries_by_mac' => 'get_entries_by_mac',
                    'remove_entries' => 'remove_entries',
                    'process_entries_now' => 'process_entries',
                    'get_my_id' => 'id_of_mac',
                    'set_task_substatus' => 'set_task_substatus',
                    'set_error' => 'set_error',
                    'get_packages' => 'get_packages'
                },
                ($protocol eq 'https')  ? ( SslKey  => $sslkeyfile,
                                            SslCert => $sslcertfile,
                                            Authenticate => \&ldap_authenticate,)
                                        : ()
            );
            $_[HEAP]{scheduled_only} = [
                "Deployment.update",
                "Deployment.reinstall",
                "Deployment.memcheck",
                "detect_hardware"
                ];
            #~ $_[KERNEL]->yield(add=>undef,undef,"job_trigger_action_halt",["00:11:22:33:44:55"],{timestamp=>1314107700});
            $log->notice("Argonaut server launched on port $server_port");
            $_[HEAP]{crawler} = POE::Component::Schedule->add(
                $_[SESSION],
                packages_crawler => DateTime::Set->from_recurrence(
                                after      => DateTime->now,
                                recurrence => sub {
                                    return $_[0]->add( days => 1 )
                                },
                            ));
            $_[KERNEL]->yield("packages_crawler"); #FIXME should be included in the recurrence
        },
        echo => sub {
            my ($kernel, $jsonrpc, $id, @params) = @_[KERNEL, ARG0..$#_ ];
            $log->info("echo (usually means server has been pinged)");
            $kernel->post( $jsonrpc => 'result' => $id, @params );
        },
        ping => sub {
            my ($kernel, $session, $jsonrpc, $id, @params) = @_[KERNEL,SESSION, ARG0..$#_ ];
            my ($mac) = @params;
            $log->info("ping $mac");
            #~ my $ok = "OK";
            eval { # try
                #~ my $res = do_action(getIpFromMac($mac),"echo",$ok);
                #~ $kernel->post( $jsonrpc => 'result' => $id, ($ok eq $res) );
              my $error = "";
              my $result;
              my $data = {'args' => []};
              ($result,$error) = POE::Kernel->call($session=>action=>undef,'ping',$mac,$data); # synchronous call
              if($error ne "") {
                $kernel->post( $jsonrpc => 'error' => $id, $error );
              } else {
                $kernel->post( $jsonrpc => 'result' => $id, $result );
              }
            };
            if ($@) { # catch
              $log->notice("Error occured : ".$@);
              $kernel->post( $jsonrpc => 'error' => $id, $@);
            };
        },
        id_of_mac => sub {
            my ($kernel, $heap, $jsonrpc, $id, @params) = @_[KERNEL,HEAP, ARG0..$#_ ];
            my ($mac) = @params;

            $log->info("searching taskid for $mac");

            while (my ($taskid,$entry) = each(%{$heap->{tasks}})) {
                if(($entry->{target} eq $mac)&&($entry->{status} eq "processing")) {
                    $heap->{tasks}->{$taskid}->{substatus} = "";
                    $kernel->post( $jsonrpc => 'result' => $id, $taskid);
                    return;
                }
            }
            $kernel->post( $jsonrpc => 'error' => $id, "Mac were not found in queue");
        },
        set_task_substatus => sub {
            my ($kernel, $heap, $session, $jsonrpc, $id, @params) = @_[KERNEL,HEAP,SESSION, ARG0..$#_ ];
            my ($taskid,$substatus,$progress) = @params;

            if(defined $progress) {
                $log->info("setting task $taskid substatus to '$substatus' ($progress %)");
            } else {
                $log->info("setting task $taskid substatus to '$substatus'");
            }

            if(!defined $heap->{tasks}->{$taskid}) {
                $kernel->post( $jsonrpc => 'error' => $id, "This task does not exists");
            } else {
                $heap->{tasks}->{$taskid}->{substatus} = $substatus;
                if(defined $progress) {
                    $heap->{tasks}->{$taskid}->{progress} = $progress;
                    if($progress>=100) {
                        flag($heap->{tasks}->{$taskid}->{target},"localboot");
                        $heap->{tasks}->{$taskid}->{status} = "processed";
                        if($delete_finished_tasks) {
                            delete $heap->{tasks}->{$taskid};
                        }
                    }
                }
                $kernel->post( $jsonrpc => 'result' => $id, "ok");
            }
        },
        set_error => sub {
            my ($kernel, $heap, $session, $jsonrpc, $id, @params) = @_[KERNEL,HEAP,SESSION, ARG0..$#_ ];
            my ($taskid,$error) = @params;

            $log->info("setting task $taskid error to '$error'");

            if(!defined $heap->{tasks}->{$taskid}) {
                $kernel->post( $jsonrpc => 'error' => $id, "This task does not exists");
            } else {
                $heap->{tasks}->{$taskid}->{status} = "error";
                $heap->{tasks}->{$taskid}->{error} = $error;
                $kernel->post( $jsonrpc => 'result' => $id, "ok");
            }
        },
        schedule => sub {
            my ($session,$heap,$date,$action,$target,$data) = @_[SESSION,HEAP,ARG0 .. $#_];
            while (defined $heap->{tasks}->{$heap->{id}}) {
                $heap->{id}++;
                if ($heap->{id}>=2147483648) { # limit to 4 bytes
                    $heap->{id} = 0;
                }
            }
            $heap->{tasks}->{$heap->{id}} = {
                    handle=>POE::Component::Schedule->add($session, action => $date, ($heap->{id},$action,$target,$data)),
                    date=>$date,
                    action=>$action,
                    target=>$target,
                    data=>$data,
                    status=>"waiting",
                    substatus=>"",
                    progress=>0,
                    error=>""
                };
        },
        add => sub {
            my ($kernel, $heap, $session, $jsonrpc, $id, @params) = @_[KERNEL,HEAP,SESSION, ARG0..$#_ ];
            my ($action,$targets,$data) = @params;

            if (ref $data ne ref {}) {
              #If data is not an hash reference, make it so to avoid errors.
              $data = {};
            }
            $log->info("adding action $action");

            if( ((! defined $data->{timestamp}) || ($data->{timestamp} eq "")) &&
                (grep {$_ eq $action} @{$heap->{scheduled_only}})) {
                # If the action is scheduled_only and there is no timestamp
                # We schedule it for now
                $data->{timestamp} = time();
            }

            if(defined $data->{timestamp} && $data->{timestamp} ne "") {
                $kernel->post( $jsonrpc => 'result' => $id, "OK" ); # asynchronous

                my $date = DateTime->from_epoch(epoch => $data->{timestamp});
                if(defined $data->{periodic} && $data->{periodic} =~ /^(\d+)_(\w+)$/) {
                    my $periodic_nb = $1;
                    my $periodic_keyword = $2;
                    foreach my $target (@{$targets}) {
                        POE::Kernel->yield(schedule=>DateTime::Set->from_recurrence(
                                after      => $date,
                                recurrence => sub {
                                    return $_[0]->add( $periodic_keyword => $periodic_nb )
                                },
                            ),$action,$target,$data);
                    }
                } else {
                    foreach my $target (@{$targets}) {
                        POE::Kernel->yield(schedule=>DateTime::Set->from_datetimes(dates => [ $date ]),
                            $action,lc($target),$data);
                    }
                }
                $log->info("action $action scheduled");
            } else {
                my $errors = "";
                my @results;
                foreach my $target (@{$targets}) {
                    my ($result,$error) = POE::Kernel->call($session=>action=>undef,$action,$target,$data); # synchronous call
                    $errors.=$error;
                    push @results,$result;
                }
                if($errors ne "") {
                    $kernel->post( $jsonrpc => 'error' => $id, $errors );
                } else {
                    $kernel->post( $jsonrpc => 'result' => $id, \@results );
                }
            }
        },
        get_entries_by_id => sub {
            my ($kernel, $heap, $jsonrpc, $id, @params) = @_[KERNEL, HEAP, ARG0..$#_ ];
            my ($ids) = @params;
            my $entries = [];
            while (my ($id,$entry) = each(%{$heap->{tasks}})) {
                if((!defined $ids) || (grep {$_ == $id} $ids)) {
                    push @{$entries}, convert_entry($entry,$id);
                }
            }
            #~ say Dumper($entries);
            $kernel->post( $jsonrpc => 'result' => $id, $entries);
        },
        get_entries_by_mac => sub { # this has not been tested
            my ($kernel, $heap, $jsonrpc, $id, @params) = @_[KERNEL, HEAP, ARG0..$#_ ];
            my ($macs) = @params;
            my $entries = [];
            while (my ($id,$entry) = each(%{$heap->{tasks}})) {
                if((!defined $macs) || (grep {lc($_) eq $entry->{'target'}} $macs)) {
                    push @{$entries}, convert_entry($entry,$id);
                }
            }
            $kernel->post( $jsonrpc => 'result' => $id, $entries);
        },
        remove_entries => sub {
            my ($kernel, $heap, $jsonrpc, $id, @params) = @_[KERNEL, HEAP,ARG0..$#_ ];
            my ($ids) = @params;

            foreach my $id (@{$ids}) {
                delete $heap->{tasks}->{$id} if defined $id;
            }

            $kernel->post( $jsonrpc => 'result' => $id, "ok");
        },
        process_entries => sub {
            my ($kernel, $heap, $jsonrpc, $id, @params) = @_[KERNEL, HEAP,ARG0..$#_ ];
            my ($ids) = @params;

            my $errors = "";
            foreach my $id (@{$ids}) {
                if ((defined $id) && (defined $heap->{tasks}->{$id})) {
                    delete $heap->{tasks}->{$id}->{handle};
                    $kernel->yield(action =>
                        $id,
                        $heap->{tasks}->{$id}->{action},
                        $heap->{tasks}->{$id}->{target},
                        $heap->{tasks}->{$id}->{data});
                } elsif (defined $id) {
                    $errors.="$id unknown\n";
                } else {
                    $errors.="id undefined\n";
                }
            }
            if ($errors ne "") {
                $kernel->post( $jsonrpc => 'error' => $id, $errors);
            } else {
                $kernel->post( $jsonrpc => 'result' => $id, "ok");
            }
        },
        action => sub {
            my ($kernel,$heap,$session,$taskid,$action,$target,$data) = @_[KERNEL,HEAP,SESSION,ARG0 .. $#_];

            my $handled = 0;
            my $res = 0;

            eval { # try
              foreach my $module (modules()) {
                #~ Is this module the one for this client and action?
                if ($module->handle_client($target,$action)) {
                  $handled = 1;
                  #~ If it is, send him the infos
                  if(defined $data->{args}) {
                    $res = $module->do_action($kernel,$heap,$session,$target,$action,$taskid,$data->{args});
                  } else {
                    $res = $module->do_action($kernel,$heap,$session,$target,$action,$taskid);
                  }
                  last;
                }
              }
              unless ($handled) {
                die "No client module can handle action $action for target $target";
              }
            };
            if ($@) { # catch
              $log->warning("Error occured : ".$@);
              if(defined $taskid) {
                $heap->{tasks}->{$taskid}->{status} = "error";
                $heap->{tasks}->{$taskid}->{error} = $@;
              }
              return (0,$@);
            };

            if((defined $taskid) && !(defined $data->{periodic})) {
                $heap->{tasks}->{$taskid}->{error} = "";
                if(grep {$_ eq $action} @{$heap->{scheduled_only}}) {
                    $heap->{tasks}->{$taskid}->{status} = "processing";
                } else {
                    $heap->{tasks}->{$taskid}->{status} = "processed";
                    if($delete_finished_tasks) {
                        delete $heap->{tasks}->{$taskid};
                    }
                }
            }
            return ($res,"");
        },
        get_packages => sub {
            my ($kernel, $jsonrpc, $id, @params) = @_[KERNEL, ARG0..$#_ ];
            my ($release,$attrs,$filters,$from,$to) = @params;

            $log->info("get_packages($release,[".join(',',@{$attrs})."],[".join(',',@{$filters})."],$from,$to)");

            eval {
                my $distributions = get_packages_info($packages_folder,undef,$release,$attrs,$filters,$from,$to);
                $kernel->post( $jsonrpc => 'result' => $id, $distributions);
            };
            if($@) {
                $log->error($@);
                $kernel->post( $jsonrpc => 'error' => $id, $@);
            }
        },
        packages_crawler => sub {
            $log->info("Getting Packages files from repositories");
            my $errors = store_packages_file($packages_folder);
            if(@{$errors} > 0) {
              $log->notice("Errors while getting Packages files : ".join(',',@{$errors}));
            }
            $log->info("done");
        },
        load_dump => sub { # this function has not been tested
            my ($kernel,$filename) = @_[KERNEL,ARG0..$#_];

            open (DUMP, $filename) or die "cannot open file";
            while (<DUMP>) {
                my $task = from_json($_);
                if(($task->{status} eq "waiting") && ($task->{data}->{timestamp} > time)) {
                    $kernel->yield(schedule=>$task->{date},$task->{action},$task->{target},$task->{data});
                }
            }
            close(DUMP);
        },
        sighup => sub {
            my ($kernel,$heap) = @_[KERNEL,HEAP];
            $log->notice("reloading config…");
            readConfig();
            $kernel->signal($heap->{jsonserver},"KILL");
            $heap->{jsonserver} = POE::Component::Server::JSONRPC::Http->new(
                Port    => $server_port,
                Handler => { # FIXME this hash should not be duplicated
                    'echo' => 'echo',
                    'ping' => 'ping',
                    'action' => 'add',
                    'get_entries' => 'get_entries_by_id',
                    'get_entries_by_id' => 'get_entries_by_id',
                    'get_entries_by_mac' => 'get_entries_by_mac',
                    'remove_entries' => 'remove_entries',
                    'process_entries_now' => 'process_entries',
                    'get_my_id' => 'id_of_mac',
                    'set_task_substatus' => 'set_task_substatus',
                    'set_error' => 'set_error',
                    'get_packages' => 'get_packages'
                },
            );
            $kernel->sig_handled();
        },
        sigint => sub {
            my ($kernel,$heap,$signal) = @_[KERNEL,HEAP,ARG0..$#_];
            $log->notice("exiting because of $signal…");
            #here, do something with waiting tasks
            if(scalar(keys(%{$_[HEAP]->{tasks}})) > 0) {
                open (DUMP, ">dump_".time.".json") or die "cannot open file";
                foreach my $task (values(%{$_[HEAP]->{tasks}})) {
                    delete $task->{handle};
                    print DUMP (to_json($task)."\n");
                }
                close(DUMP);
            }
        },
        sigchild => sub {
            $log->notice("child process exiting…");
            #~ delete $_[HEAP]->{bloquant};
        },
        _stop => sub {
            $log->notice("_stop");
        },
    },
);

POE::Kernel->run();

exit 0;

__END__

# vim:ts=2:sw=2:expandtab:shiftwidth=2:syntax:paste
