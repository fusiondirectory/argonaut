#!/usr/bin/perl

use File::Find;
use File::Copy;
use File::Path;
use File::Basename;
use Carp;
use Cwd 'getcwd';
use Class::Struct;
use Tie::IxHash;
use MLDBM 'DB_File';
use MIME::Base64;
use Getopt::Std;
use Errno qw(EAGAIN);
use POSIX qw(ceil floor);
use strict;

$SIG{CHLD} = 'IGNORE';

struct FSObject => {
	type	 => '$',
	linkdest => '$',
	size     => '$',
	mtime    => '$',
	mode     => '$',
	uid      => '$',
	gid      => '$'
};

my $DEBUG = 1;
my $SHOWPROGRESS = 0;

sub TYPE_DIR()  { 0 }
sub TYPE_FILE() { 1 }
sub TYPE_LINK() { 2 }

my $HOMEDIR  = "/tmp/profil-homedir";
my $PROFBASE = "/tmp/profil-testdir";
my $USER     = $ENV{'SUDO_USER'};
my $PROFDB   = "$PROFBASE/profil-$USER.db";
my $QUOTA    = undef;
my $EXCLFILE = "/etc/argonaut/profile-exclude.list";
my $PROFDIR  = "$PROFBASE/profil";
my $PROFDB   = "$PROFBASE/profil-$USER.db";
my $PROFLOCK = "$PROFBASE/profil-$USER.lck";
my $PROFLOCKVALIDTIME = 30;

my $pid_lockchild;

my @BLACKLIST = ();

my %HOME   = ();
tie (%HOME, "Tie::IxHash");
my %PROF   = ();

my $srcdu = 0; # Storage size for all files in HOMEDIR

##########################################################################
# Usage
##########################################################################
sub usage
{
  (@_) && print STDERR "\n@_\n\n";

  print STDERR <<"EOF";
usage: $0 [-hv] mode

  -h         : this (help) message
  -v         : be verbose
  -p	     : show progress

  -s	     : source directory (default: $ENV{'HOME'})
  -d	     : destination directory (default: /mnt/profiles/$ENV{'SUDO_USER'})
  -e	     : exclude file list (default: $EXCLFILE)
  -q         : quota limit in destination directory (default: no quota)

  Modes      : backup (copy to profile directory)
               restore (restore from profile directory)
EOF
exit(-1);
}

##########################################################################
# terminate 
##########################################################################
sub terminate
{
	print "$_[0]\n";
	untie %HOME;
	untie %PROF;
	release_lock();
	#show_progress(-1);
	exit(1);
}

##########################################################################
## main_term_handler
###########################################################################
sub main_term_handler {
	my ($signal) = @_;
	terminate( "get SIG${signal} - Terminating...\n" );
}

##########################################################################
## acquire_lock
###########################################################################
sub acquire_lock {

	my $success = 0;

	while( ! $success ) {

		if ( -e $PROFLOCK ) {
			# Lock already exists, check if timestamp
			# older than 2*PROFLOCKVALIDTIME+1
			my $difftime = 2*$PROFLOCKVALIDTIME+1;

			dprint ("(W) Lock $PROFLOCK already exists, check if timestamp is older than $difftime Seconds.");

			my $mtime = (stat($PROFLOCK))[9];
			my $current_time = time();
			if( $current_time - $mtime > $difftime ) {
				# Lock has been more than 2*PROFLOCKVALIDTIME+1 without
				# update => take over the Locks

				dprint ("(I) Lock is older than $difftime Seconds. Take Over Lock.");

				system("/bin/touch", "$PROFLOCK");
				$success = 1;
			}
			else{
				dprint ("(I) Lock is younger than $difftime Seconds. Wait...");
				sleep(5);
			}
		}
		else {
			# Lock does not exist, so create your own
			dprint ("(I) Lock does not exist, so create new lock");
			system("/bin/touch", "$PROFLOCK");
			$success = 1;
		}
	}

	# Start a child process for updating the time stamp
	dprint ("(I) Start a child process for updating the time stamp.");
	
	FORK: {
		if( $pid_lockchild = fork ) {
			# processus parent
			# PID of child process is stored in $ pid_lockchild
			dprint ("(I) Started the child process successfully.\n");

			$SIG{'INT'} = \&main_term_handler;
			$SIG{'TERM'} = \&main_term_handler;
		} 
		elsif (defined $pid_lockchild) {
			# processus fils
			# PID of the parent process is available via getppid

			while(1) {
				system("/bin/touch", "$PROFLOCK");
				print "[CHILD] Update timestamp.\n";
				sleep($PROFLOCKVALIDTIME);
			}
			exit(0);
		}
		elsif ($! == EAGAIN) {
			# EAGAIN, presumably recoverable fork error
			dprint ("(W) Starting the child process is not successful. Retrying in 5 seconds.\n");
			sleep 5;
			redo FORK;
		}
		else {
			# unrecoverable error fork
			terminate ("(E)Starting the child process failed: $!\n");
		}
	}	
}

##########################################################################
## release_lock
###########################################################################
sub release_lock {

	dprint ("(I) Csending TERM signal to child-process ...");
	if( $pid_lockchild ) {
		while(kill 0 => $pid_lockchild) {
			kill 9 => $pid_lockchild;
			sleep 1;
		}
	}
	dprint ("(I) Stopping child-process.");

	dprint ("(I) Remove the lock file.");
	unlink($PROFLOCK);
}

##########################################################################
# init_blacklist_from_file
##########################################################################
sub init_blacklist_from_file
{
	my $filename = $_[0];

	open(FILE, "<", $filename) or terminate "(E) Cannot open exclude file $filename.";
	while(<FILE>) {
		my $pattern = $_;
		chomp($pattern);

		if( $pattern =~ /^#/ ) {
			next;
		}

		my $regexp = glob2pat($pattern);
		print "(I) regexp=$regexp\n";
		push(@BLACKLIST, $regexp);
	}
	close(FILE) or terminate "(E) Cannot close exclude file $filename.";

	#foreach $key (keys %BLACKLIST) {
	#	print "exclude $key\n";
	#}
}

##########################################################################
#
# dprint: Print debug messages, simple function
#
# Argument $1: String to be printed
#
##########################################################################
sub dprint {
	my $message = shift;
	if( $DEBUG == 1 ) {
		print "$message\n";
	} 
}

##########################################################################
# show_progress
##########################################################################
#{
#	my $lastpercent;	
#
#	sub show_progress {
#		my $percent = floor(shift);
#	
#		if( $SHOWPROGRESS == 1 ) {
#			if( $percent != $lastpercent ) {
#				print "$percent Profilsynchronisation\n";
#				$lastpercent = floor($percent);
#			}
#		}
#	}
#}

sub glob2pat {
        my $globstr = shift;
        my %patmap = (
                '*' => '.*',
                '?' => '.',
                '[' => '[',
                ']' => ']',
                '\\' => '\\\\',
                '.' => '\\.',
                '^' => '\\^',
                '$' => '\\$',
                '+' => '\\+',
                '{' => '\\{',
                '}' => '\\}',
                '(' => '\\(',
                ')' => '\\)',
                '|' => '\\|',
                '/' => '\\/',
                '-' => '-'
        );
        $globstr =~ s{(.)} { $patmap{$1} || "\Q$1" }ge;
        return '^' . $globstr . '$';
}


################################################################################
# _my_rmtree: see File/Path.pm for original Version. This version denies deleting
# of sub-directories which are on other filesystems.
################################################################################
sub _my_rmtree;
sub _my_rmtree
{
    my ($path, $prefix, $up, $up_dev, $up_ino, $verbose, $safe) = @_;

    my ($dev, $ino) = lstat $path or return 0;
    unless (-d _)
    {
        print "unlink $prefix$path\n" if $verbose;
        unless (unlink $path)
        {
            carp "Can't remove file $prefix$path ($!)";
            return 0;
        }

        return 1;
    }

    print "$path $up $up_dev $dev\n" if $verbose;

    # don't delete directories on other devices
    unless ("$up_dev" eq "$dev")
    {
       carp "Won't remove directory $prefix$path on other dev.";
       return 1;
    }

    unless (chdir $path)
    {
        carp "Can't chdir to $prefix$path ($!)";
        return 0;
    }

    # avoid a race condition where a directory may be replaced by a
    # symlink between the lstat and the chdir
    my ($new_dev, $new_ino, $perm) = stat '.';
    unless ("$new_dev:$new_ino" eq "$dev:$ino")
    {
        croak "Directory $prefix$path changed before chdir, aborting";
    }

    $perm &= 07777;
    my $nperm = $perm | 0700;
    unless ($safe or $nperm == $perm or chmod $nperm, '.')
    {
        carp "Can't make directory $prefix$path read+writeable ($!)";
        $nperm = $perm;
    }

    my $count = 0;
    if (opendir my $dir, '.')
    {
        my $entry;
        while (defined ($entry = readdir $dir))
        {
            next if $entry =~ /^\.\.?$/;
            $entry =~ /^(.*)$/s; $entry = $1; # untaint
            $count +=_my_rmtree $entry, "$prefix$path/", '..', $dev, $ino,
                $verbose, $safe;
        }

        closedir $dir;
    }


    # restore directory permissions if required (in case the rmdir
    # below fails) now, while we're still in the directory and may do
    # so without a race via '.'
    unless ($nperm == $perm or chmod $perm, '.')
    {
        carp "Can't restore permissions on directory $prefix$path ($!)";
    }

    # don't leave the caller in an unexpected directory
    unless (chdir $up)
    {
        croak "Can't return to $up from $prefix$path ($!)";
    }

    # ensure that a chdir ..  didn't take us somewhere other than
    # where we expected (see CVE-2002-0435)
    unless (($new_dev, $new_ino) = stat '.'
        and "$new_dev:$new_ino" eq "$up_dev:$up_ino")
    {
        croak "Previous directory $up changed since entering $prefix$path";
    }

    print "rmdir $prefix$path\n" if $verbose;
    if (rmdir $path)
    {
        $count++;
    }
    else
    {
        carp "Can't remove directory $prefix$path ($!)";
    }

    return $count;
}

##########################################################################
##########################################################################
sub my_rmtree
{
    my ($p, $verbose, $safe) = @_;
    $p = [] unless defined $p and length $p;
    $p = [ $p ] unless ref $p;
    my @paths = grep defined && length, @$p;

    # default to "unsafe" for non-root (will chmod dirs)
    $safe = $> ? 0 : 1 unless defined $safe;

    unless (@paths)
    {
        carp "No root path(s) specified";
        return;
    }

    my $oldpwd = getcwd or do {
        carp "Can't fetch initial working directory";
        return;
    };

    my ($dev, $ino) = stat '.' or do {
        carp "Can't stat initial working directory";
        return;
    };

    # untaint
    for ($oldpwd) { /^(.*)$/s; $_ = $1 }

    my $count = 0;
    for my $path (@paths)
    {
        $count += _my_rmtree $path, '', $oldpwd, $dev, $ino, $verbose, $safe;
    }

    $count;
}

##########################################################################
# src_files:
#   helper function for scanning files and directories
##########################################################################
sub src_files {
	my $file = $_;	# Dateiname
	(my $dateiname = $File::Find::name) =~ s|^$HOMEDIR/||;

	if( $file eq "." || $file eq ".." ) {
		return;
	}

        my ($dev, $mode, $uid, $gid, $size, $mtime) = (lstat($file))[0,2,4,5,7,9];
	my $type = "";
	my $linkdest = "";

	$File::Find::prune |= ($dev != $File::Find::topdev);

	if( $File::Find::prune ) {
		dprint "(I) $dateiname on other filesystem. Skipped.";
		return;
	}

	foreach my $exclude (@BLACKLIST) {
		if( $dateiname =~ /$exclude/ ) {
			dprint "(I) $dateiname on exclude list. Skipped.";
			return;
		}
	}

	if( -d _ ) { 
		$type = TYPE_DIR;
	}
	elsif( -l _ ) {
		$type = TYPE_LINK;
		$linkdest = readlink( $file );
	}
	elsif( -f _ ) {
		$type = TYPE_FILE;
	}
	else {
		# ignore Devices, Pipes, etc.
		return;
	}

	my $object = FSObject->new();
	$object->type($type);
	$object->linkdest($linkdest);
	$object->size($size);
	$object->mtime($mtime);
	$object->mode($mode);
	$object->uid($uid);
	$object->gid($gid);

	#print "scanning $dateiname\n";
	
	$HOME{$dateiname} = $object;
	$srcdu += $size;
}


##########################################################################
# Backup
##########################################################################
sub backup() {

	#my $percent = 0;
	#
	#show_progress($percent);

	init_blacklist_from_file($EXCLFILE);

	#$percent = 1;
	#show_progress($percent);

	File::Find::find(\&src_files, $HOMEDIR);

	my $srcdumb = $srcdu / (1024*1024);
	
	dprint ("(I) storage size of all files in $HOMEDIR is $srcdumb MB");
	
	if( $QUOTA ) {
		if( $srcdumb > $QUOTA ) {
			terminate "(E) quota of $QUOTA MB exceeded. Exiting...";
		}
	}

	#$percent = 10;
	#show_progress($percent);

	#my $total_files = keys %HOME;
	#my $increment   = 70 / $total_files;

	foreach my $dateiname (keys %HOME) {
	
		#$percent += $increment;
		#show_progress($percent);	

		my $zieldateiname = "";

		if( $dateiname =~ m/[\\:\*\?\"<>\|]/ ) {
			$zieldateiname = encode_base64($dateiname,"");
		} 
		else {
			$zieldateiname = $dateiname;
		}

		my $homeobj = $HOME{$dateiname};
	
		if( $homeobj->type() == TYPE_FILE ) {
			if( exists($PROF{$dateiname}) ) {
				my $profobj = $PROF{$dateiname};
				
				if( $profobj->type() == TYPE_FILE ) {
					if( $homeobj->size() != $profobj->size() || $homeobj->mtime() != $profobj->mtime() ) {
						dprint( "(I) $dateiname File changed: Action: cp $HOMEDIR/$dateiname -> $PROFDIR/$zieldateiname\n");
						if( ! -d dirname("$PROFDIR/$zieldateiname") ) {
							mkpath(dirname("$PROFDIR/$zieldateiname")) or terminate "Mkdir failed: $!";
						}
						copy("$HOMEDIR/$dateiname", "$PROFDIR/$zieldateiname") or terminate "Copy failed: $!"; 
					}
					else {
						#dprint "(I) $dateiname File up to date.";
					}
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_DIR  ) {
					dprint "(I) $dateiname Directory replaced by file: Action(1): my_mytree $PROFDIR/$zieldateiname";
					my_rmtree("$PROFDIR/$zieldateiname");
					print "(I) $dateiname Directory replaced by file: Action(2): cp $HOMEDIR/$dateiname -> $PROFDIR/$zieldateiname";
					if( ! -d dirname("$PROFDIR/$zieldateiname") ) {
						mkpath(dirname("$PROFDIR/$zieldateiname")) or terminate "Mkdir failed: $!";
					}
					copy("$HOMEDIR/$dateiname", "$PROFDIR/$zieldateiname") or terminate "Copy failed: $!";
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_LINK ) {
					dprint "(I) $dateiname Link replaced by file: Action: cp $HOMEDIR/$dateiname -> $PROFDIR/$zieldateiname";
					if( ! -d dirname("$PROFDIR/$zieldateiname") ) {
						mkpath(dirname("$PROFDIR/$zieldateiname")) or terminate "Mkdir failed: $!";
					}
					copy("$HOMEDIR/$dateiname", "$PROFDIR/$zieldateiname") or terminate "Copy failed: $!";
					$PROF{$dateiname} = $homeobj;	
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $profobj->type()";
				}
			}
			else {
				# File does not exist in PROF
				dprint "(I) $dateiname New file. Action(1): cp $HOMEDIR/$dateiname -> $PROFDIR/$zieldateiname";
				if( ! -d dirname("$PROFDIR/$zieldateiname") ) {
					mkpath(dirname("$PROFDIR/$zieldateiname")) or terminate "Mkdir failed: $!";
				}
				copy("$HOMEDIR/$dateiname", "$PROFDIR/$zieldateiname") or terminate "Copy failed: $!";
				$PROF{$dateiname} = $homeobj;	
			}
	
		}
		elsif( $homeobj->type() == TYPE_DIR ) {
			if( exists($PROF{$dateiname}) ) {
				my $profobj = $PROF{$dateiname};
				
				if( $profobj->type() == TYPE_FILE ) {
					dprint "(I) $dateiname File replaced by directory: Action(1): rm $PROFDIR/$zieldateiname";
					unlink("$PROFDIR/$zieldateiname");
					dprint "(I) $dateiname File replaced by directory. Action(2): mkdir $PROFDIR/$zieldateiname";
					if( ! -d "$PROFDIR/$zieldateiname" ) {
						mkpath("$PROFDIR/$zieldateiname") or terminate "Mkdir failed: $!";
					}
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_DIR ) {
					#dprint "(I) DIR $filename is up to date.";
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_LINK ) {
					dprint "(I) $dateiname Link replaced by directory. Action: mkdir $PROFDIR/$zieldateiname";
					if( ! -d "$PROFDIR/$zieldateiname" ) {
						mkpath("$PROFDIR/$zieldateiname") or terminate "Mkdir failed: $!";
					}
					$PROF{$dateiname} = $homeobj;	
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $profobj->type()";
				}
			}
			else {
				# Directory does not exist in PROF
				dprint "(I) $dateiname New directory: Action: mkdir $PROFDIR/$zieldateiname";
				if( ! -d "$PROFDIR/$zieldateiname" ) {
					mkpath("$PROFDIR/$zieldateiname") or terminate "Mkdir failed: $!";
				}
				$PROF{$dateiname} = $homeobj;	
			}
		}
		elsif( $homeobj->type() == TYPE_LINK ) {
			if( exists($PROF{$dateiname}) ) {
				my $profobj = $PROF{$dateiname};
				
				if( $profobj->type() == TYPE_FILE ) {
					dprint "(I) $dateiname File replaced by link: Action: rm $PROFDIR/$zieldateiname";
					unlink("$PROFDIR/$zieldateiname");
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_DIR ) {
					dprint "(I) $dateiname Directory replaced by link: Action: my_rmtree $PROFDIR/$zieldateiname";
					my_rmtree("$PROFDIR/$zieldateiname");
					$PROF{$dateiname} = $homeobj;	
				}
				elsif( $profobj->type == TYPE_LINK ) {
					#dprint "(I) $dateiname Link is up to date.";
					$PROF{$dateiname} = $homeobj;	
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $profobj->type()";
				}
			}
			else {
				dprint "(I) $dateiname New link.";
				# Link doesn't exist in PROF
				$PROF{$dateiname} = $homeobj;	
			}
	
		}
		else {
			terminate "(E) $dateiname Unknown File Type: $homeobj->type()";
		}
	
	}
	
	#
	# Checking for deleted files in HOME
	#

	#show_progress(80);
	#$total_files = keys %PROF;
	#$increment   = 20 / $total_files;

	foreach my $dateiname (keys %PROF) {

		my $zieldateiname = "";

		if( $dateiname =~ m/[\\:\*\?\"<>\|]/ ) {
			$zieldateiname = encode_base64($dateiname,"");
		} 
		else {
			$zieldateiname = $dateiname;
		}

		#$percent += $increment;
		#show_progress($percent);	

		if( !exists($HOME{$dateiname}) ) {

			my $dsttype = $PROF{$dateiname}->type();
	
			if ($dsttype == TYPE_FILE) {
 				dprint "(I) $dateiname File deleted: Action: rm $PROFDIR/$zieldateiname";
 				unlink("$PROFDIR/$zieldateiname");
 			}
 			elsif ($dsttype == TYPE_DIR) {
 				dprint "(I) $dateiname Directory deleted: Action: my_rmtree $PROFDIR/$zieldateiname";
 				my_rmtree("$PROFDIR/$zieldateiname");
 			}
 			elsif ($dsttype == TYPE_LINK) {
 				dprint "(I) $dateiname Link deleted.";
 			}
 			else {
 				terminate "(E) $dateiname Unknown File Type: $PROF{dateiname}->type()";
			}

			delete($PROF{$dateiname});
		}
	}

	#show_progress(100);

}

##########################################################################
# Restore
##########################################################################
sub restore() {

	init_blacklist_from_file($EXCLFILE);
	
	File::Find::find(\&src_files, $HOMEDIR);

	#
	# Checking for deleted files in PROF
	#
	foreach my $dateiname (keys %HOME) {

       		foreach my $exclude (@BLACKLIST) {
                	if( $dateiname =~ /$exclude/ ) {
                        	next;
                	}
        	}
	
		if( !exists($PROF{$dateiname}) ) {
	
			my $srctype = $HOME{$dateiname}->type();

			if( $srctype == TYPE_FILE ) {
				dprint "(I) $dateiname File deleted: Action: rm $HOMEDIR/$dateiname";
				if( -e "$HOMEDIR/$dateiname" ) {
					unlink("$HOMEDIR/$dateiname");
				}
			}
			elsif( $srctype == TYPE_DIR ) {
				dprint "(I) $dateiname Directory deleted: Action: my_rmtree $HOMEDIR/$dateiname";
				my_rmtree("$HOMEDIR/$dateiname");
			}
			else {
				dprint "(I) $dateiname Link deleted.";
			}
	
			delete($HOME{$dateiname});
		}
	}


	#
	# Handle Directories
	#
	foreach my $dateiname (keys %PROF) {
	
       		foreach my $exclude (@BLACKLIST) {
                	if( $dateiname =~ /$exclude/ ) {
                        	next;
                	}
        	}

		my $profobj = $PROF{$dateiname};
		my $zieldateiname = "";

		if( $dateiname =~ m/[\\:\*\?\"<>\|]/ ) {
			$zieldateiname = encode_base64($dateiname,"");
		} 
		else {
			$zieldateiname = $dateiname;
		}

		if( $profobj->type() == TYPE_DIR ) {
			if( exists($HOME{$dateiname}) ) {
				my $homeobj = $HOME{$dateiname};
				
				if( $homeobj->type() == TYPE_FILE ) {
					dprint "(I) $dateiname File replaced by directory: Action(1): rm $HOMEDIR/$dateiname";
					unlink("$HOMEDIR/$dateiname");
					dprint "(I) $dateiname File replaced by directory. Action(2): mkdir $HOMEDIR/$dateiname";
					if( ! -d "$HOMEDIR/$dateiname" ) {
						mkpath("$HOMEDIR/$dateiname") or terminate "Mkpath failed: $!";
					}
					chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
					chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
				}
				elsif( $homeobj->type == TYPE_DIR ) {
					if( $homeobj->uid() != $profobj->uid() ||
					    $homeobj->gid() != $profobj->gid() ||
					    $homeobj->mode() != $profobj->mode() ||
					    $homeobj->mtime() != $profobj->mtime() ) {
						chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
						chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
						utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
						dprint "(I) $dateiname Permissions, ownership, or mtime fixed.";
					}
					else {
						#dprint "(I) $dateiname File up to date.";
					}
				}
				elsif( $homeobj->type == TYPE_LINK ) {
					dprint "(I) $dateiname Link replaced by directory. Action(1): rm $HOMEDIR/$dateiname";
					unlink("$HOMEDIR/$dateiname");
					dprint "(I) $dateiname Link replaced by directory. Action(2): mkdir $HOMEDIR/$dateiname";
					if( ! -d "$HOMEDIR/$dateiname" ) {
						mkpath("$HOMEDIR/$dateiname") or terminate "Mkpath failed: $!";
					}
					chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
					chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
					#$HOME{$dateiname} = $profobj;	
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $homeobj->type()";
				}
			}
			else {
				# Verzeichnis existiert nicht in HOME
				dprint "(I) $dateiname New directory: Action: mkdir $HOMEDIR/$dateiname";
				if( ! -d "$HOMEDIR/$dateiname" ) {
					mkpath("$HOMEDIR/$dateiname") or terminate "Mkpath failed: $!";
				}
				chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
				chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
				utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
			}
		}
	}


	foreach my $dateiname (keys %PROF) {

       		foreach my $exclude (@BLACKLIST) {
                	if( $dateiname =~ /$exclude/ ) {
                        	next;
                	}
        	}
	
		my $profobj = $PROF{$dateiname};
		my $zieldateiname = "";

		if( $dateiname =~ m/[\\:\*\?\"<>\|]/ ) {
			$zieldateiname = encode_base64($dateiname,"");
		} 
		else {
			$zieldateiname = $dateiname;
		}
	
		if( $profobj->type() == TYPE_FILE ) {
			if( exists($HOME{$dateiname}) ) {
				my $homeobj = $HOME{$dateiname};
				
				if ($homeobj->type() == TYPE_FILE) {
					if( $homeobj->size() != $profobj->size() || $homeobj->mtime() != $profobj->mtime() ) {
						dprint( "(I) $dateiname File changed: Action: cp $PROFDIR/$zieldateiname -> $HOMEDIR/$dateiname\n");
						if( ! -d dirname("$HOMEDIR/$dateiname") ) {
							mkpath(dirname("$HOMEDIR/$dateiname")) or terminate "Mkdir failed: $!";
						}
						copy("$PROFDIR/$zieldateiname", "$HOMEDIR/$dateiname") or terminate "Copy failed: $!";
						chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
						chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
						utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
					}
					else {
						if( $homeobj->uid() != $profobj->uid() ||
						    $homeobj->gid() != $profobj->gid() ||
						    $homeobj->mode() != $profobj->mode() ) {
							chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
							chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
							dprint "(I) $dateiname Permissions and ownership fixed.";

						}
						else {
							#dprint "(I) $dateiname File up to date.";
						}
					}
				}
				elsif ($homeobj->type() == TYPE_DIR) {
					dprint "(I) $dateiname Directory replaced by file: Action(1): my_rmtree $HOMEDIR/$dateiname";
					my_rmtree("$HOMEDIR/$dateiname");
					print "(I) $dateiname Directory replaced by file: Action(2): cp $PROFDIR/$zieldateiname -> $HOMEDIR/$dateiname";
					if( ! -d dirname("$HOMEDIR/$dateiname") ) {
						mkpath(dirname("$HOMEDIR/$dateiname")) or terminate "Mkdir failed: $!";
					}
					copy("$PROFDIR/$zieldateiname", "$HOMEDIR/$dateiname") or terminate "Copy failed: $!";
					chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
					chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
				}
				elsif ($homeobj->type() == TYPE_LINK) {
					dprint "(I) $dateiname Link replaced by file: Action: cp $PROFDIR/$zieldateiname -> $HOMEDIR/$dateiname";
					if( ! -d dirname("$HOMEDIR/$dateiname") ) {
						mkpath(dirname("$HOMEDIR/$dateiname")) or terminate "Mkdir failed: $!";
					}
					copy("$PROFDIR/$zieldateiname", "$HOMEDIR/$dateiname") or terminate "Copy failed: $!";
					chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
					chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $homeobj->type()";
				}
			}
			else {
				# Data doesn't exist in HOME
				my $dir = dirname("$HOMEDIR/$dateiname");
				if( ! -d $dir ) {
					dprint "(I) $dateiname New file. Action(0): mkpath $dir";
					mkpath($dir) or terminate "Mkdir failed: $!";
				}
				dprint "(I) $dateiname New file. Action(1): cp $PROFDIR/$zieldateiname -> $HOMEDIR/$dateiname";
				copy("$PROFDIR/$zieldateiname", "$HOMEDIR/$dateiname") or terminate "Copy failed: $!";
				chmod ($profobj->mode(), "$HOMEDIR/$dateiname") or terminate "Chmod failed: $!";
				chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
				utime ($profobj->mtime(), $profobj->mtime(), "$HOMEDIR/$dateiname") or terminate "Utime failed: $!";
			}
	
		}
		elsif( $profobj->type() == TYPE_LINK ) {
			if( exists($HOME{$dateiname}) ) {
				my $homeobj  = $HOME{$dateiname};
				my $linkdest = $profobj->linkdest();
				

				if( $homeobj->type() == TYPE_FILE ) {
					dprint "(I) $dateiname File replaced by link: Action(1): rm $HOMEDIR/$dateiname";
					unlink("$HOMEDIR/$dateiname");
					dprint "(I) $dateiname File replaced by link: Action(2): ln -s $linkdest $HOMEDIR/$dateiname";	
					symlink($profobj->linkdest(), "$HOMEDIR/$dateiname") or terminate "Symlink failed: $!";
					#chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					my $uid = $profobj->uid();
					my $gid = $profobj->gid();
					system("chown -h '$uid $HOMEDIR/$dateiname'");
					system("chgrp -h '$gid $HOMEDIR/$dateiname'");
				}
				elsif( $homeobj->type == TYPE_DIR ) {
					dprint "(I) $dateiname Directory replaced by link: Action(1): my_rmtree $HOMEDIR/$dateiname";
					my_rmtree("$HOMEDIR/$dateiname");
					dprint "(I) $dateiname Directory replaced by link: Action(2): ln -s $linkdest $HOMEDIR/$dateiname";	
					symlink($profobj->linkdest(), "$HOMEDIR/$dateiname") or terminate "Symlink failed: $!";
					#chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
					my $uid = $profobj->uid();
					my $gid = $profobj->gid();
					system("chown -h '$uid $HOMEDIR/$dateiname'");
					system("chgrp -h '$gid $HOMEDIR/$dateiname'");
				}
				elsif( $homeobj->type == TYPE_LINK ) {
					# PrÃ¼fen ob Linkziel identisch
					if( $homeobj->linkdest() eq $profobj->linkdest() ) {
						#dprint "(I) $dateiname Link is up to date.";
					}
					else {
						dprint "(I) $dateiname Link changed: Action(1): rm $HOMEDIR/$dateiname";
						unlink("$HOMEDIR/$dateiname");
						dprint "(I) $dateiname Link changed: Action(2): ln -s $linkdest $HOMEDIR/$dateiname";	
						symlink($profobj->linkdest(), "$HOMEDIR/$dateiname") or terminate "Symlink failed: $!";
						#chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
						my $uid = $profobj->uid();
						my $gid = $profobj->gid();
						system("chown -h '$uid $HOMEDIR/$dateiname'");
						system("chgrp -h '$gid $HOMEDIR/$dateiname'");
					}
				}
				else {
					terminate "(E) $dateiname Unknown File Type: $homeobj->type()";
				}
			}
			else {
				# Link doesn't exist in HOME
				my $dir = dirname("$HOMEDIR/$dateiname");
				if( ! -d $dir ) {
					dprint "(I) $dateiname New Link. Action(0): mkpath $dir";
					mkpath($dir) or terminate "Mkdir failed: $!";
				}
				if( -l "$HOMEDIR/$dateiname" ) {
					unlink("$HOMEDIR/$dateiname");
				}
				my $linkdest = $profobj->linkdest();
				dprint "(I) $dateiname New Link: Action: ln -s $linkdest $HOMEDIR/$dateiname";	
				symlink($linkdest, "$HOMEDIR/$dateiname") or terminate "Symlink failed: $!";
				#chown ($profobj->uid(), $profobj->gid(), "$HOMEDIR/$dateiname") or terminate "Chown failed: $!";
				my $uid = $profobj->uid();
				my $gid = $profobj->gid();
				system("chown -h $uid '$HOMEDIR/$dateiname'");
				system("chgrp -h $gid '$HOMEDIR/$dateiname'");
			}
	
		}
		elsif( $profobj->type() == TYPE_DIR ) {
			next;
		}
		else {
			terminate "(E) $dateiname Unknown File Type: $profobj->type()";
		}
	
	}
		

}

##########################################################################
##########################################################################
# MAIN
##########################################################################
##########################################################################

#-------------------------------------------------------------------------
# Parameter handling
#-------------------------------------------------------------------------
use vars qw/ %opt /;
my $opt_string = 'hvps:d:q:e:';
getopts( "$opt_string", \%opt ) or usage("Wrong parameters");
usage("Help") if $opt{h};

if( defined $opt{s} ) {
	$HOMEDIR  = $opt{s};
}

if( defined $opt{d} ) {
	$PROFBASE = $opt{d};
	$PROFDIR  = "$PROFBASE/profil";
	$PROFDB   = "$PROFBASE/profil-$USER.db";
	$PROFLOCK = "$PROFBASE/profil-$USER.lck";
}

if( defined $opt{q} ) {
	$QUOTA = $opt{q};
}

if( defined $opt{e} ) {
	$EXCLFILE = $opt{e};
}

if( defined $opt{p} ) {
	$SHOWPROGRESS = 1;
}

if( defined $opt{v} ) {
	$DEBUG=1;
}
else {
	$DEBUG=0;
}

if( ! -d $PROFDIR ) {
	mkpath($PROFDIR) or terminate "mkpath failed: $!"; 
}


my $mode_str = shift @ARGV;
my $mode;

#-------------------------------------------------------------------------
# Locking
#-------------------------------------------------------------------------
acquire_lock();

#-------------------------------------------------------------------------
# Assign Database to Hash
#-------------------------------------------------------------------------
tie (%PROF, 'MLDBM', $PROFDB);

#-------------------------------------------------------------------------
# backup or restore
#-------------------------------------------------------------------------

if( $mode_str eq "backup") {
	backup(); 
}
elsif( $mode_str eq "restore" ) { 
	restore(); 
}
else {
  	usage("Please supply a correct mode.");
}

#-------------------------------------------------------------------------
# End
#-------------------------------------------------------------------------
untie %HOME;
untie %PROF;
release_lock();
#show_progress(-1);
exit(0);

