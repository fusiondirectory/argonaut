#!/usr/bin/perl -w
# Copyright (c) 2008 Landeshauptstadt München
# Copyright (c) 2008 GONICUS GmbH
#
# Authors: Matthias Benkmann
#          Holger Burbach
#          Jan-Marek Glogowski
#          Jens Nitschke
#          Cajus Pollmeier
#          
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


use lib "/usr/lib/argonaut";

use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Util qw(:escape);
use File::Path;
use File::Path qw(mkpath);
use File::Copy;
use File::Basename;
use XML::LibXML;
use Argonaut::Common qw(:ldap :file :array);
use Argonaut::LDAP qw(ldap_get_object);

use strict;
use warnings;

my @GOTO_LOCALES = ();
my @app_attributes;

sub translate 
{
  my $length = @GOTO_LOCALES;
  my $string = $_[0];

  chomp($string);

  if( $length == 0 ) {
    open(FD, "/etc/argonaut/atgonaut-locales.dat") || die "The file /etc/argonaut/argonaut-locales.dat is unavailable";
    @GOTO_LOCALES = <FD>;
    close(FD);
  }

  my $result = $string;

  foreach my $line (@GOTO_LOCALES) {
    my $de;
    my $en;

    ($en, $de) = split(/=/, $line);
    chomp($de) if( defined $de );
    chomp($en);
    if( $en eq $string ) {
      $result = $de;
    }
  }

  return $result;
}

sub sort_and_uniq 
{
  return sort keys %{{ map { $_ => 1 } @_ }};
}

sub app2var 
{
  my $attr= "";
  my $val= "";

        $_[0] =~ /^$/ && next;
        if ($_[0] =~ /^([^=]+)="([^:][^"]*)"$/) {
                $attr= $1;
                $val = $2;
        }
        if ($_[0] =~ /^([^=]+)=\": ([^"]+)"$/) {
                $attr= $1;
                $val = decode_base64($2);
        }

        if ($attr =~ /^gosaApplicationParameter$/i && $val =~ /[^:]$/) {
                $val =~ /^([^:]+):(.+)$/;
                $attr= $1;
                $val = $2;
        }

        if ($attr =~ /^gosaApplicationParameter$/i && $val =~ /:$/) {
                $val =~ /^([^:]+):$/;
                $attr= $1;
                $val = "";
        }

  $ENV{"$attr"}=$val;
  # TODO: here include only the $attr that are not listed in the array
        push(@app_attributes, $attr);
}

##########################################################################
# Startup message
##########################################################################
printf("%d %s\n", 0, translate("Initialization started..."));

##########################################################################
# Initializing
##########################################################################
my $uid = $ENV{'USER'};
my $HOME = $ENV{'HOME'};
my $MAC = $ENV{'MAC'};

my $ldapinfo = argonaut_ldap_parse_config_ex(); #ref to hash
my ($ldapbase,$ldapuris) = ($ldapinfo->{"LDAP_BASE"}, $ldapinfo->{"LDAP_URIS"});

my @createdObjects = ();
my @ldif = ();
my @tocopy = ();

##########################################################################
# Init LDAP
##########################################################################
my $ldap = Net::LDAP->new( $ldapuris ) or die "$@";
my $mesg = $ldap->bind ;    # an anonymous bind

##########################################################################
# Getting Release
##########################################################################

# checking for object class members
$mesg = $ldap->search( # perform a search
                        base   => "$ldapbase",
                        filter => "(&(objectclass=gotoWorkstation)$$ldapinfo{UNIT_TAG_FILTER}(macAddress=$MAC))",
                        attrs  => [ 'FAIclass' ]
                      );
 
$mesg->code && die $mesg->error;

my @RELEASES = $mesg->entries;

my $RELEASE = undef;
my $DN;

foreach my $entry (@RELEASES) {
  $DN = $entry->dn();
  $RELEASE = $entry->get_value('FAIClass');
  if( $RELEASE ) {
    $RELEASE =~ s/^.* ://;
  }
}

if( ! $RELEASE ) {
  # no FAIClass available at the workstation -> Check the object class
  $mesg = $ldap->search( # perform a search
                        base   => "$ldapbase",
                        filter => "(&(objectclass=gotoWorkstationTemplate)$$ldapinfo{UNIT_TAG_FILTER}(FAIClass=*)(member=" . escape_filter_value($DN) . "))",
                        attrs => ['FAIclass' ]
          );
  $mesg->code && die $mesg->error;

  @RELEASES=$mesg->entries;

  $RELEASE = undef;
  foreach my $entry (@RELEASES) {
    $RELEASE = $entry->get_value('FAIClass');
    if( $RELEASE ) {
      $RELEASE =~ s/^.* ://;
    }
  }
}

my $LDAP_RELEASE = '';

if( $RELEASE ) {
  $ENV{'RELEASE'}=$RELEASE;

  my @RELEASES = split(/\//, $RELEASE);
  $LDAP_RELEASE = 'ou=' . join( ',ou=', reverse( @RELEASES ) ) . ',';
}


##########################################################################
# Retrieving all Applications -> @APPLICATIONS
##########################################################################
$mesg = $ldap->search( # perform a search
                        base   => "${LDAP_RELEASE}ou=apps,$ldapbase",
                        filter => "(&(objectclass=gosaApplication)$$ldapinfo{UNIT_TAG_FILTER})",
                        scope => 'one'
                      );
 
$mesg->code && die $mesg->error;

my @APPLICATIONS=$mesg->entries;

my %APPLICATIONKEYS= ();
foreach my $application (@APPLICATIONS) {
  my $dn = $application->dn();
  my $cn = $application->get_value ('cn');

  if ( $dn =~ /^cn=$cn,$LDAP_RELEASE/ ) {
    $APPLICATIONKEYS{$cn} = $application;
  }
}

##########################################################################
# Read menu from LDAP
# ATTENTION! If $RELEASE is "foo" and there exist subreleases such as
# "foo/1.1" and "foo/1.2", then this will pull in those, too.
##########################################################################
my @results = ldap_get_object(ldap => $ldap,
                            basedn => $ldapbase,
                            user => $uid,
                            timeout => 10,
                            filter => $$ldapinfo{UNIT_TAG_FILTER},
                            subquery => "(|(objectClass=gotoMenuEntry)(objectClass=gotoSubmenuEntry))",
                            dups => 0,
                            mergeResults => 0,
                            attributeSelectionRegexes => ["\@$RELEASE/.*"],
                            );
@results or die "Error reading from LDAP";


# Icon path has to be created before LDAP checkout, because directory icons are
# created directly when reading the menus structure
mkpath "$HOME/.kde/share/icons" || 
  die "Create the directory '$HOME/.kde/share/icons' failed";

# The complete menu layout will be stored in %MENU with the following structure
# (given by example)
# { "halut" => { "2.1.0" => { "__name" => "Startmenü"
#                             "__prio" => "0"
#                             "__type" => "menu"
#                             "büroprogramme" => { "__name" => "Büroprogramme"
#                                                  "__prio" => "1"
#                                                  "__type" => "menu"
#                                                  "writer" => { "__name" => "writer"
#                                                                "__prio" => "2"
#                                                                "__type" => "app"  
#                                                              }
#                                                }
#                           }
#              }
# }
# If the current release does not have a sub-release, then the "2.1.0" level
# in the example above won't exist.
#
# __name is the cn of the goto(Sub)Menuentry node.
# __type can be "app", "menu" or "seppl"
# __prio corresponds to gosaApplicationPriority
# __icon corresponds to gosaApplicationIcon for menus
#
# The keys are the parts of the DN without the attribute name.
#
# gosaApplicationParameter and other attributes are NOT stored in %MENU.
#
# %MENU only ever stores the menu tree for the release $RELEASE. In the
# above example that's "halut/2.1.0". If there are other subreleases, these
# are (see earlier comment) included in @results, but when %MENU is
# constructed these branches are eliminated.
my %MENU = ();
my %USER_APPLICATIONS = ();
my $STARTMENU; #reference to the hash for the start menu

# Create the mapping levels for release and subrelease, i.e.
# %MENU = { "halut" => "2.1.0" => {} }
# This initial mapping is important! Do not attempt to merge it with
# the tree generation later!
{
  $STARTMENU = \%MENU;
  foreach my $release (split(/\//, $RELEASE))
  {
    $STARTMENU->{$release} = {};
    $STARTMENU = $STARTMENU->{$release};
  }
}
$STARTMENU->{"__name"} = "Startmenü";
$STARTMENU->{"__type"} = "menu";
$STARTMENU->{"__prio"} = "0";
$STARTMENU->{"__icon"} = "folder";


sub countSlashes
{
  my $str = shift;
  my $count = 0;
  my $pos = -1;
  while(($pos = index($str, "/", $pos + 1)) >= 0) { ++$count;}
  return $count;
}

# Now construct %MENU (see structure description further above).
#
# Each entry of @results is a Net::LDAP::Entry object that stores
# a menu structure with pseudo-attributes such as
# halut/2.1.0/büroprogramme/objectclass.
#
# The entries of @results are sorted in decreasing order of
# precedence. We reverse the list before iterating over it, so
# that later entries (i.e. higher precedence) can overwrite
# attributes of earlier entries.
#
# While constructing %MENU we also gather gosaApplicationParameter
# values and stuff them into %APPLICATIONKEYS. That way the application
# parameters will also be listed in order of increasing precedence
# inside %APPLICATIONKEYS.
#
# Another thing the following part does is to fill %USER_APPLICATIONS
# with the names (i.e. keys into %APPLICATIONKEYS) of all applications
# found in the user's menu. A hash is used only to achieve uniqueness.
#
foreach my $menuInfo (reverse @results)
{
  # From the list of all pseudo-attributes we extract the .../objectclass
  # attributes and cut off the "/objectclass". We sort the resulting list
  # by number of contained slashes. This gives us the complete menu
  # structure sorted so that less deeply nested entries come before
  # more deeply nested ones.
  # This sorting is important! Do not attempt to optimize it away
  # (see later comment).
  my @menuPartPrefixes = ();
  foreach my $attr ($menuInfo->attributes)
  {
    if ($attr =~ m%^(.*)/objectClass$%i) { push @menuPartPrefixes, $1; }
  }
  @menuPartPrefixes = 
     sort { my $x = countSlashes($a); my $y = countSlashes($b);
            $x < $y ?  -1 : ($x > $y ? 1 : ($a cmp $b));}
     @menuPartPrefixes;

handle_prefix:  
  foreach my $prefix (@menuPartPrefixes)
  {
    my $menuentry = \%MENU;
    my @components = split(/\//, $prefix);
    my $lastComponent = pop(@components);
    foreach my $cname (@components)
    {
      # The following line is essential! It makes sure that only those prefixes
      # get turned into menu entries for which all components but the last already exist
      # in the tree. If our $RELEASE is a top-level release such as "halut", then
      # this gets rid of all entries for sub-releases such as 
      # "halut/2.1.0/büroprogramme".
      # This only works because of the sorting done earlier. The sorting makes sure that
      # "halut/büroprogramme" gets processed before "halut/büroprogramme/writer", allowing 
      # the latter to be created.
      # "halut/2.1.0" on the other hand will never be created, because the respective
      # LDAP node does not have objectClass=goto(Sub)MenuEntry, which means that
      # @results does not have an entry halut/2.1.0/objectclass, which means that
      # @menuPartPrefixes does not have an entry "halut/2.1.0", which means that
      # "halut/2.1.0/büroprogramme" will be skipped because of the missing "2.1.0" level
      # in %MENU.
      # The only way an entry such as "halut/2.1.0/büroprogramme" will ever make it into
      # the tree is if %MENU has been initialized to {"halut" => {"2.1.0"} => {}} by the
      # initialization of %MENU from $RELEASE.
      if (!exists($menuentry->{$cname})) { next handle_prefix; }
      $menuentry = $menuentry->{$cname};
    } 

    $menuentry->{$lastComponent} = {};
    $menuentry = $menuentry->{$lastComponent};
    
    my $name = $menuInfo->get_value($prefix . "/cn");
    $menuentry->{"__name"} = $name;
    my $prio = $menuInfo->get_value($prefix . "/gosaapplicationpriority");
    defined($prio) or $prio = 1; # make sure every entry has a prio
    $menuentry->{"__prio"} = $prio;
    my $type = "app";
    foreach my $class ($menuInfo->get_value($prefix . "/objectclass"))
      { $type = "menu" if ("\L$class" eq "gotosubmenuentry"); }
      
    foreach my $param ($menuInfo->get_value($prefix . "/gosaapplicationparameter"))
    {
      if ($param eq "*separator*") { $type = "seppl"; }
      $APPLICATIONKEYS{$name}->add("gosaApplicationParameter", $param);
    }

    # generate directory icon
    my $directoryIcon = $menuInfo->get_value($prefix . '/gosaapplicationicon');
    my $iconPath = 'folder';

    if ( $directoryIcon ) {
      # If the data starts with a slash, it's actually a icon abs path
      if (substr( $directoryIcon, 0, 1 ) eq '/' ) {
        $iconPath = $directoryIcon;
      }
      else {
        $iconPath = "$HOME/.kde/share/icons/$name.png";
        if( ! -e $iconPath ) {
          open(FDICON, "> $iconPath") ||
            print "Datei '$iconPath' could not be opened for writing.\n";
          binmode FDICON;
          print FDICON "$directoryIcon";
          close(FDICON);
        }
        else {
          print "Datei '$iconPath' already exists\n";
        }
      }
    }
    $menuentry->{"__icon"} = $iconPath;

    $menuentry->{"__type"} = $type;
    if ($type eq "app") { $USER_APPLICATIONS{$name} = 1;}
  }
  
}

##########################################################################
# Unbind LDAP
##########################################################################
$mesg = $ldap->unbind;   # take down session


##########################################################################
# create directories
##########################################################################
my @DIRS=("$HOME/.config/menus",
  "$HOME/.local/share/desktop-directories",
  "$HOME/.local/share/applications",
  "$HOME/.argonaut/applications",
  "$HOME/.argonaut/log/applications",
  "$HOME/.argonaut/log/plugins",
  "$HOME/Desktop",
  "$HOME/.kde/shutdown" );

foreach my $dir (@DIRS) {
  #-d $dir && rmtree($dir);
  mkpath $dir || die "Create the directory $dir failed";
}

##########################################################################
# prepare logout script
##########################################################################

if ( -s "$HOME/.kde/shutdown/argonaut-end-session" || -f "$HOME/.kde/shutdown/argonaut-end-session" ) {
  unlink "$HOME/.kde/shutdown/argonaut-end-session";
}

symlink("/usr/bin/argonaut-end-session", "$HOME/.kde/shutdown/argonaut-end-session");


##########################################################################
# Finding all plugins to be executed
##########################################################################
my @PLUGINS=glob("/etc/argonaut/plugins/S[0-9][0-9]*");

##########################################################################
# before starting any plugins, we calculate the step information
# needed for the progress bar
##########################################################################
my $STEP = 10000 / ( scalar(keys %USER_APPLICATIONS) + @PLUGINS );

##########################################################################
# Loop through plugins and source the code
##########################################################################
my $CURRENT = 0;
my ($PROGRESS, $STRING);

foreach my $plugin (@PLUGINS) {
  open(FILE, $plugin) || die "$plugin file can not be opened";
  my $NAME = <FILE> || die "First line of file $plugin could not be read";
  close(FILE);
  $NAME =~ s/^#NAME://;
  $CURRENT = $CURRENT + $STEP;
  $PROGRESS = $CURRENT / 100;
  $STRING = translate($NAME);
  printf("%d %s\n", $PROGRESS, $STRING);

  my $plugin_basename = basename($plugin);

  system("/bin/sh $plugin &> $HOME/.argonaut/log/plugins/$plugin_basename.log");
}

##########################################################################
# Delete links for all applications
##########################################################################
unlink(glob("$HOME/.kde/share/applnk/*.desktop"));
unlink(glob("$HOME/.local/share/applications/*.desktop"));
unlink(glob("$HOME/.local/share/desktop-directories/*.directory"));
unlink(glob("$HOME/.argonaut/applications/*"));

# Cleanup desktop links
foreach my $file (glob("$HOME/Desktop/*.desktop")) {
  if( -l $file ) {
      unlink($file) unless( -f $file );
  }
}

##########################################################################
# Creating floppy icon
##########################################################################

my $idoutput=`id $uid`;

-f "$HOME/Desktop/Diskettenlaufwerk" && unlink("$HOME/Desktop/Diskettenlaufwerk");
-f "$HOME/Desktop/Diskette" && unlink("$HOME/Desktop/Diskette");

if( $idoutput =~ m/(floppy)/ ) {
  open(FILE, "> $HOME/Desktop/Diskette");
  print FILE "[Desktop Action Format]\n";
  print FILE "Exec=kfloppy %v\n";
  print FILE "Name=Format\n";
  print FILE "Name[de]=Formatieren\n";
  print FILE "\n";
  print FILE "[Desktop Entry]\n";
  print FILE "Actions=Format\n";
  print FILE "Dev=/dev/fd0\n";
  print FILE "Encoding=UTF-8\n";
  print FILE "Icon=3floppy_mount\n";
  print FILE "MountPoint=/media/floppy0\n";
  print FILE "ReadOnly=false\n";
  print FILE "Type=FSDevice\n";
  print FILE "UnmountIcon=3floppy_unmount\n";
  print FILE "X-KDE-Priority=TopLevel\n";
  close(FILE);
}

##########################################################################
# Looping through applications
##########################################################################

foreach my $app (keys %USER_APPLICATIONS)  {

  my @attributes = ( 'gosaApplicationExecute', 
      'gosaApplicationName',
      'description',
      'gosaApplicationParameter' );

  $CURRENT += $STEP;
  $PROGRESS = $CURRENT / 100;

  # Skip non-existing application
  my $application = $APPLICATIONKEYS{$app};
  if( ! $application ) {
    next;
  }

  $STRING = translate("Adapting application '%s'");
  $STRING =~ s/%s/$app/;
  printf("%d %s\n", $PROGRESS, $STRING);

  # test if application is installed and executable
  my $execfile = $application->get_value('gosaApplicationExecute');
  $execfile =~ s/^(\S*)\s.*/$1/;

  my $execpath = "";
  $execpath = `which $execfile`;
  chomp($execpath);

  if( -x $execpath ) {

    # Reset all attributes
    foreach my $attribute (@attributes) {
      $ENV{"$attribute"}="";
    }
    
    @app_attributes = ();
  
    # Export attributes (especially gosaApplicationParameters)
    # Because the application parameters have been appended to
    # the attribute list during construction of %MENU in
    # order of precedence, this loop already takes into account
    # overwriting of default app parameters with group-specific
    # parameters.
    foreach my $attribute (@attributes) {
      my @attr = $application->get_value("$attribute");
      foreach my $value (@attr) {
        app2var("$attribute=\"$value\"");
      }
    }
  
  
    # create required entries and print message
    my $applicationFlags = $application->get_value('gosaApplicationFlags');

    #create_menu_entry;
    if( $applicationFlags =~ m/M/ ) {
                  open(FILE, "> $HOME/.local/share/applications/$app.desktop");
      print FILE "[Desktop Entry]\n";
      print FILE "Type=Application\n";
      print FILE "Encoding=UTF-8\n";
      print FILE "Exec=$ENV{'gosaApplicationExecute'}\n";
      print FILE "Name=$ENV{'gosaApplicationName'}\n";
      print FILE "GenericName=$ENV{'description'}\n";
      print FILE "Comment=$ENV{'description'}\n";
      print FILE "Icon=$HOME/.kde/share/icons/$app.png\n";
      print FILE "Terminal=false\n";
      close(FILE);

      #we can't create desktop links without the menu entry
      #create_desktop_link;
      if( $applicationFlags =~ m/D/ ) {
                    symlink("$HOME/.local/share/applications/$app.desktop", 
          "$HOME/Desktop/$app.desktop");
      }
    } else {
      print "gosaApplicationFlags not set in LDAP for application $ENV{'gosaApplicationName'}, $ENV{'gosaApplicationExecute'}, skipping";
    }

    if( -r "/etc/argonaut/application/$app" ) {
      system("/bin/sh /etc/argonaut/application/$app &> $HOME/.argonaut/log/applications/$app.log");
    } else {
      my $logonscript = $application->get_value('gotoLogonScript');
  
      if( $logonscript ) {
        open(FDSCRIPT, "> $HOME/.argonaut/applications/$app") ||
          die "$HOME/.argonaut/applications/$app could not be opened for writing.";
        $logonscript =~ s/\015//g;
        $logonscript =~ s/\032//g;
        print FDSCRIPT "# Include argonaut support library and configuration\n";
        print FDSCRIPT ". /usr/lib/argonaut/argonaut-support.lib\n";
        print FDSCRIPT ". /etc/argonaut/argonaut-agent.conf\n";
        print FDSCRIPT "$logonscript\n";
        close(FDSCRIPT);
  
        system("/bin/sh $HOME/.argonaut/applications/$app &> $HOME/.argonaut/log/applications/$app.log"); 
      }
    }
  
    # Extract Icon from LDAP
    my $applicationIcon = $application->get_value('gosaApplicationIcon');
  
    if ( $applicationIcon ) {
      open(FDICON, "> $HOME/.kde/share/icons/$app.png") ||
        die "$HOME/.kde/share/icons/$app.png could not be opened for writing.";
      binmode FDICON;
      print FDICON "$applicationIcon";
      close(FDICON);
    }

    # clean environment
    foreach my $app_attribute (@app_attributes) {
      delete $ENV{$app_attribute};
    }
    
  }

}

##########################################################################
# Creating menu structure
##########################################################################

my $menuxml = XML::LibXML->createDocument( "1.0", "UTF-8" );
$menuxml->createInternalSubset(
        "Menu", "-//freedesktop//DTD Menu 1.0//EN",
                  "http://www.freedesktop.org/standards/menu-spec/1.0/menu.dtd" );

my $menuNode = $menuxml->createElement( 'Menu' );
$menuxml->setDocumentElement( $menuNode );

# Add default layout and application directories
$menuNode->addNewChild( undef, 'DefaultAppDirs' );
my $dflt_layout = $menuNode->addNewChild( undef, 'DefaultLayout' );
my $merger = $dflt_layout->addNewChild( undef, "Merge" );
$merger->setAttribute( 'type', 'menus' );
$merger = $dflt_layout->addNewChild( undef, "Merge" );
$merger->setAttribute( 'type', 'files' );

sub create_menu
{
  my ($xml, $menu, $category, $categoryprefix) = @_;
  my $name = $menu->{"__name"};

  $xml->appendTextChild( "Name", $name );
  $xml->appendTextChild( "Directory", $name . ".directory" );
  my $include = $xml->addNewChild( undef, 'Include' );
  my $layout = $xml->addNewChild( undef, "Layout" ); 
  
  my @entries = grep { ref($_) } values %$menu;
  @entries = sort { $a->{"__prio"} <=> $b->{"__prio"} } @entries;
  
  my $have_added_merge_menus = 0;
  
  foreach my $entry (@entries)
  {
    if ($entry->{"__type"} eq "app")
    {
      # Before the first file entry, add the <Merge type="menus"/>
      if( not $have_added_merge_menus) 
      {
        my $merger = $layout->addNewChild( undef, "Merge" );
        $merger->setAttribute( 'type', 'menus' );
        $have_added_merge_menus = 1;
      }
      
      $layout->appendTextChild( 'Filename', $entry->{"__name"} . ".desktop" );
      $include->appendTextChild( 'Category', $category );
      $include->appendTextChild( 'Filename', $entry->{"__name"} . ".desktop" );
    }
    elsif ($entry->{"__type"} eq "menu")
    {
      $layout->appendTextChild( 'Menuname', $entry->{"__name"} );
    }
    elsif ($entry->{"__type"} eq "seppl")
    {
      $layout->addNewChild( undef, 'Separator' );
    }
  }

  # If we haven't done so yet, add <Merge type="menus"/>  
  if( not $have_added_merge_menus) 
  {
    my $merger = $layout->addNewChild( undef, "Merge" );
    $merger->setAttribute( 'type', 'menus' );
  }
  { # Add <Merge type="files"/>
    my $merger = $layout->addNewChild( undef, "Merge" );
    $merger->setAttribute( 'type', 'files' );
  }

  # Write directory file
  if( open(FILE, "> $HOME/.local/share/desktop-directories/$name.directory") ) {
      print FILE <<"EOF";
[Desktop Entry]
Comment=
GenericName=
Icon=$menu->{"__icon"}
Name=$name
EOF
  close( FILE );
  }  
   # Add submenus
  foreach my $entry (@entries)
  {
    if ($entry->{"__type"} eq "menu")
    {
      my $submenuxml = $xml->addNewChild( undef, "Menu" );
      my $cat = $categoryprefix;
      $cat .= "/" unless (length($cat) == 0);
      $cat .= $entry->{"__name"};
      create_menu($submenuxml, $entry, $cat, $cat);
    }
  }
}

create_menu($menuNode, $STARTMENU, "Startmenü", "");

# We don't want the System menu - delete it
{
  my $node = $menuNode->addNewChild( undef, 'Menu' );
  $node->appendTextChild( 'Name', 'System' );
  $node->addNewChild( undef, 'Deleted' );
}

$menuxml->toFile( "$HOME/.config/menus/applications-kmenuedit.menu", 1 );

printf("%d %s\n", 100, "Done.");

