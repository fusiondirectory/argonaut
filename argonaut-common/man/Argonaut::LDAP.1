.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Argonaut::LDAP 3"
.TH Argonaut::LDAP 3 "2011-08-23" "Argonaut 1.0" "Argonaut Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Argonaut::LDAP \- Support library for goto\-* scripts to access LDAP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Argonaut::Common qw(:ldap);
\&  use Argonaut::LDAP qw(ldap_get_object);
\& 
\&  my $ldapinfo = goto_ldap_parse_config_ex(); #ref to hash
\&  my ($ldapbase,$ldapuris) = ($ldapinfo\->{"LDAP_BASE"}, $ldapinfo\->{"LDAP_URIS"});
\& 
\&  my $ldap = Net::LDAP\->new( $ldapuris, timeout => $timeout ) or die; 
\&  $ldap\->bind() ;  # anonymous bind
\&
\&   # list context
\&  my @results = ldap_get_object(ldap => $ldap,
\&                                basedn => $ldapbase,
\&                                user => $user,
\&                                timeout => $timeout,
\&                                filter => $filter,
\&                                debug => $debug,
\&                                objectClass => $objectClass,
\&                                cnou => $cn,
\&                                subquery => $subquery,
\&                                sublevel => $sublevel,
\&                                subconflict => $subconflict,
\&                                attributeSelectionRegexes => \e@attributeSelectionRegexes,
\&                                enctrigger => $enctrigger,
\&                                format => $format,
\&                                dups => $dups,
\&                                mergeResults => $mergeResults
\&                );
\&
\&  @results or die;
\&  
\&   # scalar context
\&  my $result = ldap_get_object(...);
\&  $result or die;
.Ve
.ie n .SH "DESCRIPTION of ""ldap_get_object"""
.el .SH "DESCRIPTION of \f(CWldap_get_object\fP"
.IX Header "DESCRIPTION of ldap_get_object"
\&\f(CW\*(C`ldap_get_object()\*(C'\fR reads information about an object (usually a user, but can also be a
workstation, a \s-1POSIX\s0 group,...) from \s-1LDAP\s0. \f(CW\*(C`ldap_get_object()\*(C'\fR understands gosaGroupOfNames and
posixGroups and will not only return properties of the queried object itself but also properties 
inherited from groups of both types.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
.IP "\fBldap\fR" 4
.IX Item "ldap"
An object of type Net::LDAP that is already bound. Required.
.IP "\fBbasedn\fR" 4
.IX Item "basedn"
The base \s-1DN\s0 to use for all searches. Required.
.IP "\fBuser\fR/\fBcnou\fR and \fBobjectClass\fR" 4
.IX Item "user/cnou and objectClass"
You must pass either \f(CW\*(C`user\*(C'\fR or \f(CW\*(C`cnou\*(C'\fR. 
If you pass \f(CW\*(C`user\*(C'\fR, \f(CW\*(C`objectClass\*(C'\fR is ignored and \f(CW\*(C`ldap_get_object()\*(C'\fR will search for an object
with \f(CW\*(C`objectClass=posixAccount\*(C'\fR and \f(CW\*(C`uid\*(C'\fR equal to the value passed as \f(CW\*(C`user\*(C'\fR.
.Sp
If you pass \f(CW\*(C`cnou\*(C'\fR, then you must also pass \f(CW\*(C`objectClass\*(C'\fR and  \f(CW\*(C`ldap_get_object()\*(C'\fR will
search for an object with the given \f(CW\*(C`objectClass\*(C'\fR and a \f(CW\*(C`cn\*(C'\fR equal to the value passed as \f(CW\*(C`cnou\*(C'\fR. If
no such object is found, it will attempt to find an object with the given \f(CW\*(C`objectClass\*(C'\fR and
\&\f(CW\*(C`ou\*(C'\fR equal to the value of \f(CW\*(C`cnou\*(C'\fR.
.IP "\fBattributeSelectionRegexes\fR and \fB\s-1CONFLICT\s0 \s-1RESOLUTION\s0\fR" 4
.IX Item "attributeSelectionRegexes and CONFLICT RESOLUTION"
A reference to a an array of regular expressions (as strings) that select the attributes to be returned
and determines how to proceed in case there are multiple sources for an attribute 
(e.g. the user's posixAccount node and a posixGroup the user is a member of).
.Sp
Each regex selects all attributes with matching names.
.Sp
If the regex starts with the character \f(CW\*(C`@\*(C'\fR (which is ignored for the matching), 
then attribute values from different sources will be merged (i.e. the result will include all values).
.Sp
If attributeRegex does \s-1NOT\s0 start with \f(CW\*(C`@\*(C'\fR, then an attribute from the queried object's own node
beats a posix group, which beats an object group (=gosaGroupOfNames) that
includes the object directly which beats an object group that contains a posix group containing
the object. Object groups containing other object groups are not supported by GOsa, so this
case cannot occur.
.Sp
If 2 sources with the same precedence (e.g. 2 posix groups) provide an attribute
of the same name, selected by a regex that doesn not start with \f(CW\*(C`@\*(C'\fR, then
a \s-1WARNING\s0 is signalled and the program picks one of the conflicting attributes.
.Sp
If multiple attribute regexes match the same attribute, the 1st matching
attribute regex's presence or absence of \f(CW\*(C`@\*(C'\fR determines conflict resolution.
.Sp
Matching is always performed against the \fIcomplete\fR attribute name as if the regex had
been enclosed in \f(CW\*(C`^...$\*(C'\fR, i.e.
an attribute regex \f(CW\*(C`name\*(C'\fR will \s-1NOT\s0 match an attribute called \f(CW\*(C`surname\*(C'\fR. Neither will the regex
\&\f(CW\*(C`sur\*(C'\fR.
.Sp
Matching is always performed case-insensitive.
.Sp
If the parameter \f(CW\*(C`attributeSelectionRegexes\*(C'\fR is not passed, it defaults to \f(CW\*(C`@.*\*(C'\fR.
.IP "\fBmergeResults\fR" 4
.IX Item "mergeResults"
If \f(CW\*(C`mergeResults\*(C'\fR is \f(CW\*(C`false\*(C'\fR and \f(CW\*(C`ldap_get_object()\*(C'\fR is evaluated in list context, then it
will return a list of Net::LDAP::Entry objects where each object represents the attributes on a given
precedence level. The first entry gives the attributes that come from the own node, i.e. those with
the highest precedence.
.Sp
Attributes selected with a non\-\f(CW\*(C`@\*(C'\fR regex, i.e. those for which only one source is permitted, are always
found in the first entry and only there. For these attributes all conflicting values from lower precedence
levels are always discarded, so \f(CW\*(C`mergeResults=false\*(C'\fR only makes sense when requesting
merged attributes via \f(CW\*(C`@\*(C'\fR.
.Sp
If \f(CW\*(C`mergeResults\*(C'\fR is \f(CW\*(C`true\*(C'\fR (the default) or if \f(CW\*(C`ldap_get_object()\*(C'\fR is evaluated in scalar context,
then only one Net::LDAP::Entry will be returned that contains all of the requested attributes.
.IP "\fBdups\fR" 4
.IX Item "dups"
Net::LDAP::Entry does not perform duplicate removal on its attribute value lists by default.
If \f(CW\*(C`dups=true\*(C'\fR (the default), the results returned from \f(CW\*(C`ldap_get_object()\*(C'\fR may contain attributes that contain 
duplicate entries. If this would confuse your code, pass \f(CW\*(C`dups=false\*(C'\fR and duplicate values will be
eliminated (at the cost of a few \s-1CPU\s0 cycles).
.IP "\fBtimeout\fR" 4
.IX Item "timeout"
If \f(CW\*(C`timeout\*(C'\fR is passed, \s-1LDAP\s0 requests will use a timeout of this number of seconds.
Note that this does \fInot\fR mean that \f(CW\*(C`ldap_get_object\*(C'\fR will finish
within this time limit, since several \s-1LDAP\s0 requests may be involved.
.Sp
Default timeout is 10s.
.IP "\fBfilter\fR" 4
.IX Item "filter"
\&\f(CW\*(C`filter\*(C'\fR is an LDAP-Expression that will be ANDed with all user/object/group
searches done by this program.
.Sp
Use this to filter by \f(CW\*(C`gosaUnitTag\*(C'\fR.
.IP "\fBsubquery\fR" 4
.IX Item "subquery"
The \f(CW\*(C`subquery\*(C'\fR parameter is an \s-1LDAP\s0 filter such as \f(CW\*(C`objectClass=gotoMenuItem\*(C'\fR. For the subtrees
rooted at the object's own
node and at all of its containing groups' nodes, an \s-1LDAP\s0 query using this filter will be done.
The attributes of all of the objects resulting from these queries will be treated as if they
were attributes of the node at which the search was rooted. The names of these pseudo-attributes  
have the form \f(CW\*(C`foo/bar/attr\*(C'\fR.
.IP "\fBsublevel\fR" 4
.IX Item "sublevel"
\&\f(CW\*(C`sublevel\*(C'\fR specifies the maximum number of slashes the pseudo-attribute
names will contain. If the complete name of a pseudo-attribute 
has more slashes than the given number, the name will be shortened to the longest
suffix that contains this many slashes. Specifying a \f(CW\*(C`sublevel\*(C'\fR of 0 will
effectively merge all subquery nodes with the user/object/group node
so that in the end result their attributes are indistinguishable from
those of the user/object/group node.
.Sp
Default \f(CW\*(C`sublevel\*(C'\fR is 9999.
.Sp
Note: attribute regex matching is performed on the full name with all slashes.
.IP "\fBsubconflict\fR" 4
.IX Item "subconflict"
\&\f(CW\*(C`subconflict\*(C'\fR is a number that determines when 2 pseudo-attributes are treated as being
in conflict with each other. 2 pseudo-attributes are treated as
conflicting if the results of removing the shortest suffixes containing
\&\f(CW\*(C`subconflict\*(C'\fR slashes from their names (shortened according to \f(CW\*(C`sublevel\*(C'\fR) 
are identical. E.g. with \f(CW\*(C`subconflict=0\*(C'\fR
the pseudo-attributes \f(CW\*(C`foo/bar\*(C'\fR and \f(CW\*(C`foo/zoo\*(C'\fR are not conflicting,
whereas with \f(CW\*(C`subconflict=1\*(C'\fR they are. Default \f(CW\*(C`subconflict\*(C'\fR is 1.
.IP "\fBdebug\fR" 4
.IX Item "debug"
If \f(CW\*(C`debug\*(C'\fR is \f(CW\*(C`true\*(C'\fR, then lots of debug output (mostly all of the nodes considered in
constructing the result) is printed to stdout.
.IP "\fBenctrigger\fR" 4
.IX Item "enctrigger"
This parameter is only relevant when \f(CW\*(C`debug\*(C'\fR is \f(CW\*(C`true\*(C'\fR. It affects the way, attribute values
are printed. If \f(CW\*(C`enctrigger\*(C'\fR is passed, it is interpreted as a regular expression and all DNs and attribute 
values will be tested against this regex. Whenever a value matches, it will be output
base64 encoded. Matching is performed case-sensitive and unless ^ and $ are
used in the regex, matching substrings are enough to trigger encoding.
.Sp
If no \f(CW\*(C`enctrigger\*(C'\fR is specified, the default \f(CW\*(C`[\ex00\-\ex1f]\*(C'\fR is used (i.e. base64
encoding will be used whenever a value contains a control character).
If you pass \f(CW\*(C`enctrigger=none\*(C'\fR, encoding will be completely disabled.
.IP "\fBformat\fR" 4
.IX Item "format"
This parameter is only relevant when \f(CW\*(C`debug\*(C'\fR is \f(CW\*(C`true\*(C'\fR. It affects the way, attribute values
are printed. Format \f(CW"a:v"\fR means to print 
\&\f(CW\*(C`attributeName: value\*(C'\fR pairs. Format \f(CW\*(C`v\*(C'\fR means to print the values only.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs, or post any suggestions, to the fusiondirectory mailing list fusiondirectory-users or to
<https://forge.fusiondirectory.org/projects/argonaut\-agents/issues/new>
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
This code is part of FusionDirectory <http://www.fusiondirectory.org>
.IP "Copyright (C) 2008 Matthias S. Benkmann" 2
.IX Item "Copyright (C) 2008 Matthias S. Benkmann"
.PD 0
.IP "Copyright (C) 2011 FusionDirectory project" 2
.IX Item "Copyright (C) 2011 FusionDirectory project"
.PD
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the
\&\s-1GNU\s0 General Public License for more details.
