#!/usr/bin/perl -w

#######################################################################
#
# fai2ldif
#
# Copyright (c) 2014 The FusionDirectory Project <contact@fusiondirectory.org>
#
# Authors: CÃ´me Bernigaud
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#
#######################################################################

use strict;
use warnings;

use 5.008;

use Net::LDAP;
use Getopt::Long;

# used to manage files
use Path::Class;

#~ use Argonaut::Libraries::FAI qw(:flags);

my $dump_dir      = "/var/lib/fai/config";
my $verbose       = 0;
my $base          = '<BASE>';
my $faibaserdn    = 'ou=fai,ou=configs,ou=systems';
my $faipackagerdn = 'ou=packages';
my $faidiskrdn    = 'ou=disk';
my $dist          = '';

Getopt::Long::Configure ("bundling");

GetOptions( 'v|verbose'         => \$verbose,
            'h|help'            => \&usage,
            'c|config-space=s'  => \$dump_dir,
            'd|dist=s'          => \$dist,
            'b|base=s'          => \$base
          )
  or usage( 'Wrong parameters' );

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
sub usage
{
  (@_) && print STDERR "\n@_\n\n";

  print STDERR << "EOF";
 usage: $0 [-hv] [-c config_space] [-d dist] -b base class

  -h  : this (help) message
  -v  : be verbose
  -c  : config space (default: ${dump_dir})
  -b  : ldap base
  -d  : distribution

EOF
  exit -1;
}

my $class = shift or usage('Missing class parameter');
$faibaserdn = $dist.$faibaserdn;

if (-f "$dump_dir/package_config/$class") {
  my $file = file("$dump_dir/package_config/$class");

  print "parsing $file\n" if $verbose;

  my $name = $file;
  $name =~ s|^.*/||;

  my @lines = $file->slurp;

  foreach my $line ( @lines ) {
    # remove comments
    $line =~ s/#.*$//;
    # remove \n from the end of each line
    chomp $line;

    next if ( $line =~ /^$/ );

    # only process for lines beginning with "class", and extracting the 2nd word (the class name)
    if ( $line =~ /^PACKAGES\s+([^ ]+)(\s+([^ ]*))?/ ) {
      my $cn = $name;
      $cn .= '-'.$3 if $3;
      print "dn: cn=$cn,$faipackagerdn,$faibaserdn,$base\n";
      print "cn: $cn\n";
      print 'objectClass: top'."\n";
      print 'objectClass: FAIclass'."\n";
      print "objectClass: FAIpackageList\n";
      print "FAIinstallMethod: $1\n";
    } else {
      my @packages = split(/\s+/, $line);
      foreach my $package (@packages) {
        print "FAIpackage: $package\n";
      }
    }
  }
}

if (-f "$dump_dir/disk_config/$class") {
  my $file = file("$dump_dir/disk_config/$class");

  print "parsing $file\n" if $verbose;

  my $name = $file;
  $name =~ s|^.*/||;

  my @lines = $file->slurp;

  my $disk_cn;
  my $partitionNr=0;

  print "dn: cn=$class,$faidiskrdn,$faibaserdn,$base\n";
  print "cn: $class\n";
  print 'objectClass: top'."\n";
  print 'objectClass: FAIclass'."\n";
  print "objectClass: FAIpartitionTable\n";
  print "FAIpartitionMethod: setup-storage\n";

  foreach my $line ( @lines ) {
    # remove comments
    $line =~ s/#.*$//;
    # remove \n from the end of each line
    chomp $line;

    next if ( $line =~ /^$/ );

    if ( $line =~ /^disk_config\s+([^\s]+)\s+(.+)/ ) {
      if ($1 eq 'lvm') {
        print "lvm\n" if $verbose;
      } else {
        $disk_cn = $1;
        print "dn: cn=$disk_cn,cn=$class,$faidiskrdn,$faibaserdn,$base\n";
        print "cn: $disk_cn\n";
        print 'objectClass: top'."\n";
        print 'objectClass: FAIclass'."\n";
        print "objectClass: FAIpartitionDisk\n";
        print "FAIdiskType: disk\n";
        foreach my $option (split ' ',$2) {
          print "FAIdiskOption: $option\n";
        }
      }
    } else {
      if ($line =~ /([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)\s+([^\s]+)(\s+createopts="(.*)")?(\s+tuneopts="(.*)")?/) {
        print "dn: FAIpartitionNr=$partitionNr,cn=$disk_cn,cn=$class,$faidiskrdn,$faibaserdn,$base\n";
        print "FAIpartitionNr: $partitionNr\n";
        print "cn: $partitionNr\n";
        print 'objectClass: top'."\n";
        print 'objectClass: FAIclass'."\n";
        print "objectClass: FAIpartitionEntry\n";
        $partitionNr++;
        print "FAIpartitionType: $1\nFAImountPoint: $2\nFAIpartitionSize: $3\nFAIfsType: $4\nFAImountOptions: $5\n";
        chomp $7 if defined $7;
        chomp $9 if defined $9;
        print "FAIfsCreateOptions: $7\n" if defined $7;
        print "FAIfsTuneOptions: $9\n" if defined $9;
      } else {
        print STDERR "Could not parse line $line\n";
      }
    }
  }

}
